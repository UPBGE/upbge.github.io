

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Python and the Game Engine &mdash; UPBGE Manual</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme_overrides.css?v=523733c9" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=f4332903"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Inheritance And Composition" href="understanding_inheritance.html" />
    <link rel="prev" title="Introduction to Scripting" href="introduction.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            UPBGE Manual
              <img src="../../_static/upbge_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Manual</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../editors/index.html">Editors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../logic_bricks/index.html">Logic Bricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../logic_nodes/index.html">Logic Nodes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Python Scripting</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction to Scripting</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Python and the Game Engine</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#integrating-python-in-the-game-engine">Integrating Python in the Game Engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-your-python-scripts">Writing Your Python Scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reference-material-and-documentation">Reference Material and Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-your-scripts">Testing Your Scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#d-world-elements">3D World Elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#understanding-the-code">Understanding the Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-initialization">Global Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#event-management">Event Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#internal-functions">Internal Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#game-interaction">Game Interaction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#more-python">More Python</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reusing-your-script">Reusing Your Script</a></li>
<li class="toctree-l3"><a class="reference internal" href="#file-organization-groups-and-layers">File Organization - Groups and Layers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tweaks-and-adjustments-getting-your-hands-dirty">Tweaks and Adjustments - Getting Your Hands Dirty</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-game-engine-api-application-programming-interface">Using the Game Engine API - Application Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#libload-libnew-libfree-liblist-todo-to-be-replaced-with-new-ones">LibLoad(), LibNew(), LibFree(), LibList() (TODO to be replaced with new ones)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#globaldict-loadglobaldict-saveglobaldict">globalDict, loadGlobalDict(), saveGlobalDict()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bge-types">bge.types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-kx-gameobject">Class KX_GameObject</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bge-render">bge.render</a></li>
<li class="toctree-l3"><a class="reference internal" href="#window-and-mouse">Window and Mouse</a></li>
<li class="toctree-l3"><a class="reference internal" href="#world-settings-todo-to-be-removed-changed">World Settings (TODO to be removed/changed)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stereo-settings-todo-to-be-changed">Stereo Settings (TODO to be changed)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#material-settings-todo-to-be-changed">Material Settings (TODO to be changed)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">Others</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bge-events">bge.events</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bge-texture">bge.texture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bge-constraints">bge.constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mathutils-math-types-and-utilities">Mathutils - Math Types and Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vector">Vector</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matrix">Matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="#euler-and-quaternion">Euler and Quaternion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#aud-audio-system">aud - Audio System</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-basic-audio-playback-todo-to-be-adapted-to-new-api">Example: Basic Audio Playback (TODO to be adapted to new API)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bgl-opengl-wrapper">bgl - OpenGL Wrapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blf-font-drawing">blf - Font Drawing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="understanding_inheritance.html">Inheritance And Composition</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../python_components/index.html">Python Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../physics/index.html">Physics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../datablocks/index.html">Data-Blocks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/index.html">Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary/index.html">Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contribute</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">Contribute</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">UPBGE Manual</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Python Scripting</a></li>
      <li class="breadcrumb-item active">Python and the Game Engine</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/manual/python_scripting/python_game_engine.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="python-and-the-game-engine">
<span id="python-game-engine"></span><h1>Python and the Game Engine<a class="headerlink" href="#python-and-the-game-engine" title="Link to this heading"></a></h1>
<p>This whole chapter is organized into three main parts: why, what, and how. Thus, if you have read from the beginning, you already have solid reasons to start using scripts for your project, and you understand what Python is. The final part of this chapter will cover how to use your Python knowledge inside the game engine. This part is divided into four submodules:</p>
<ul class="simple">
<li><p>Integrating Python in the game engine.</p></li>
<li><p>Writing your Python scripts.</p></li>
<li><p>Designing your script.</p></li>
<li><p>Using the Game Engine API.</p></li>
</ul>
<section id="integrating-python-in-the-game-engine">
<h2>Integrating Python in the Game Engine<a class="headerlink" href="#integrating-python-in-the-game-engine" title="Link to this heading"></a></h2>
<p>In the game engine, the script interface is controller-centric by design. Therefore, you can consider the Python script simply as a more complex controller to replace the Expression or the Boolean controllers. In those cases, the script will be responsible for controlling how the sensors are related with the actuators of a given object. In fact, the sensors, actuators, and even the object where you are calling the script from are all attributes of the controller.</p>
<p>As we mentioned earlier, with a Python script you can control external devices, control multiple objects at once, and much more. However, you will never be free from using a logic brick framework. And from the combination of logic bricks, individual sensors, global sensors, and actuators, the elegance of your system will arise.</p>
<p>In the first example, you will find a very simple case study of how to make your Python controller work. It will cover the basic behavior of receiving sensors’ input in the script and triggering actuators from it.</p>
<p>Download the example <a class="reference download internal" download="" href="../../_downloads/0dc71e4d83590095e14a62c660f9f381/003_template.zip"><code class="xref download docutils literal notranslate"><span class="pre">003_template.zip</span></code></a>, extract it and load the abracadabra.blend file.</p>
<figure class="align-default" id="id2">
<img alt="../../_images/introduction_to_scripting_05.png" src="../../_images/introduction_to_scripting_05.png" />
<figcaption>
<p><span class="caption-text">Abracadabra</span><a class="headerlink" href="#id2" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Launch the game and keep the spacebar pressed. In above figure, you can see the result before and after you press the key. Can you read the spinning text? It may not be impressive, but it certainly is didactic. Here is the script behind this effect:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">bge</span>
<span class="kn">from</span> <span class="nn">bge</span> <span class="kn">import</span> <span class="n">logic</span>

<span class="c1"># Use bge module to get/set game property + transform</span>
<span class="n">cont</span> <span class="o">=</span> <span class="n">logic</span><span class="o">.</span><span class="n">getCurrentController</span><span class="p">()</span>
<span class="n">owner</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">owner</span>
<span class="n">scene</span> <span class="o">=</span> <span class="n">logic</span><span class="o">.</span><span class="n">getCurrentScene</span><span class="p">()</span>
<span class="n">objects</span> <span class="o">=</span> <span class="n">scene</span><span class="o">.</span><span class="n">objects</span>
<span class="n">font_object</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="s2">&quot;Text&quot;</span><span class="p">]</span>

<span class="c1"># Use bpy.types.TextCurve attributes to set other text settings (size, body, etc)</span>
<span class="n">font_object_data</span> <span class="o">=</span> <span class="n">font_object</span><span class="o">.</span><span class="n">blenderObject</span><span class="o">.</span><span class="n">data</span>

<span class="n">sens</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">sensors</span><span class="p">[</span><span class="s1">&#39;my_sensor&#39;</span><span class="p">]</span>
<span class="n">act</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">actuators</span><span class="p">[</span><span class="s1">&#39;my_actuator&#39;</span><span class="p">]</span>

<span class="k">if</span> <span class="n">sens</span><span class="o">.</span><span class="n">positive</span><span class="p">:</span>
  <span class="n">cont</span><span class="o">.</span><span class="n">activate</span><span class="p">(</span><span class="n">act</span><span class="p">)</span>
  <span class="n">font_object_data</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="s2">&quot;CADABRA&quot;</span>
  <span class="n">font_object_data</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="n">font_object_data</span><span class="o">.</span><span class="n">resolution_u</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">cont</span><span class="o">.</span><span class="n">deactivate</span><span class="p">(</span><span class="n">act</span><span class="p">)</span>
  <span class="n">font_object_data</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="s2">&quot;ABRA&quot;</span>
  <span class="n">font_object_data</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">font_object_data</span><span class="o">.</span><span class="n">resolution_u</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>This script is triggered from a keyboard sensor, runs from a controller in the camera object, activates an actuator in the camera itself, and changes a property in the text object. Next figure shows logic bricks for this one.</p>
<figure class="align-default" id="id3">
<img alt="../../_images/introduction_to_scripting_06.png" src="../../_images/introduction_to_scripting_06.png" />
<figcaption>
<p><span class="caption-text">Simple logic bricks with a Python controller</span><a class="headerlink" href="#id3" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Let’s look at it from the beginning:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">bge</span>
<span class="kn">from</span> <span class="nn">bge</span> <span class="kn">import</span> <span class="n">logic</span>
</pre></div>
</div>
<p>The first lines import the module bge and then the submodule logic. No big deal here. We actually don’t need to explicitly import the bge module since we are importing a submodule directly. However, it doesn’t hurt to do it. Lines 4 and 5 will store the current controller in a variable and create a pointer to the object where it was called from (known as _owner_). We are not using the owner variable here, but it’s good to be familiar with it. You will be using it a lot.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use bge module to get/set game property + transform</span>
<span class="n">cont</span> <span class="o">=</span> <span class="n">logic</span><span class="o">.</span><span class="n">getCurrentController</span><span class="p">()</span>
<span class="n">owner</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">owner</span>
</pre></div>
</div>
<p>The following lines get more elements from the game to be used in the script: scene will give you direct access to the current scene; objects is the current list to be used later; font_obj is one element of the objects list (accessed by its name in Blender).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scene</span> <span class="o">=</span> <span class="n">logic</span><span class="o">.</span><span class="n">getCurrentScene</span><span class="p">()</span>
<span class="n">objects</span> <span class="o">=</span> <span class="n">scene</span><span class="o">.</span><span class="n">objects</span>
<span class="n">font_obj</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="s2">&quot;Text&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above code we used the bge module to get the font game object but using the bge module only we are limiting us to get/set the game object plus to make transforms with this game object (position, rotate or scale). Whether we want to access to the inner parts of the Text object and modify them then we need to understand that the Text object is a bpy object (type TextCurve) and we need to adquire its bpy object data. Once adquired we can use all the properties of bpy.types.TextCurve class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use bpy.types.TextCurve attributes to set other text settings (size, body, etc)</span>
<span class="n">font_object_data</span> <span class="o">=</span> <span class="n">font_object</span><span class="o">.</span><span class="n">blenderObject</span><span class="o">.</span><span class="n">data</span>
</pre></div>
</div>
<p>Remember when we said that the game engine is controller-centric? All the sensors and actuators are accessed from the controller, not from the object they belong to (its owner), as you might expect. Lines 11 and 12, respectively, read the built-in sensor and actuator list to get the ones we are looking for.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sens</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">sensors</span><span class="p">[</span><span class="s1">&#39;my_sensor&#39;</span><span class="p">]</span>
<span class="n">act</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">actuators</span><span class="p">[</span><span class="s1">&#39;my_actuator&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In a way similar to how logic bricks work, we are going to activate the actuator if the sensor triggers positive and deactivate it otherwise. The deactivation happens in the frame after the sensor ceases to validate, for example, the key is unpressed or the mouse button is released.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">sens</span><span class="o">.</span><span class="n">positive</span><span class="p">:</span>
   <span class="n">cont</span><span class="o">.</span><span class="n">activate</span><span class="p">(</span><span class="n">act</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
   <span class="n">cont</span><span class="o">.</span><span class="n">deactivate</span><span class="p">(</span><span class="n">act</span><span class="p">)</span>
</pre></div>
</div>
<p>We are not restricted to controlling only actuators, though. Lines 19-21 and 24-26 change the text, the size and the resolution of the object when you press/release the spacebar:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">font_object_data</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="s2">&quot;CADABRA&quot;</span>
<span class="n">font_object_data</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">font_object_data</span><span class="o">.</span><span class="n">resolution_u</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">font_object_data</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="s2">&quot;ABRA&quot;</span>
<span class="n">font_object_data</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">font_object_data</span><span class="o">.</span><span class="n">resolution_u</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>This file can be simple, but holds the essence of the game engine architecture design. Now is a good time to go over the other game engine template files that come with the example <a class="reference download internal" download="" href="../../_downloads/0dc71e4d83590095e14a62c660f9f381/003_template.zip"><code class="xref download docutils literal notranslate"><span class="pre">003_template.zip</span></code></a> and spend some time studying those examples.</p>
</section>
<section id="writing-your-python-scripts">
<h2>Writing Your Python Scripts<a class="headerlink" href="#writing-your-python-scripts" title="Link to this heading"></a></h2>
<p>If you haven’t started your own scripts, now is a good time to do so. You will need a text editor, the API modules documented, and a good way to test your files.</p>
<section id="text-editors">
<h3>Text Editors<a class="headerlink" href="#text-editors" title="Link to this heading"></a></h3>
<p>It’s important to find a script editor that you find pleasant to work with. The most important features you will be looking for are: syntax coloring and highlighting, auto indentation, and auto completion. You can find editors with even more features than these, so experiment with different alternatives and decide what’s best for you.</p>
</section>
<section id="upbge-text-editor">
<h3>UPBGE Text Editor<a class="headerlink" href="#upbge-text-editor" title="Link to this heading"></a></h3>
<p>As you probably know, UPBGE has its own internal text editor (see next figure). Although it may not be as powerful as software designed exclusively for this particular task, it can be very convenient. It’s useful for quick tests, small scripts, or when you want to keep everything bundled inside the Blender file. Here are its main features:</p>
<ul class="simple">
<li><p>Syntax highlighting;</p></li>
<li><p>Dynamic font sizes;</p></li>
<li><p>Indentation conversion (spaces to tabs and vice versa);</p></li>
<li><p>Line counting and navigation;</p></li>
<li><p>Search over multiple internal files;</p></li>
<li><p>Sync with external files;</p></li>
<li><p>Icon viewer (small but marvellous feature to get what is the icon that you want to use).</p></li>
</ul>
<figure class="align-default" id="id4">
<img alt="../../_images/introduction_to_scripting_07.png" src="../../_images/introduction_to_scripting_07.png" />
<figcaption>
<p><span class="caption-text">UPBGE internal text editor</span><a class="headerlink" href="#id4" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="visual-studio-code-or-pycharm">
<h3>Visual Studio Code or PyCharm<a class="headerlink" href="#visual-studio-code-or-pycharm" title="Link to this heading"></a></h3>
<p>External editors as Visual Studio Code or PyCharm have many more features than internal UPBGE Text editor. The weakest point of using external editors is the auto-completion and the documentation visualization directly from the code.</p>
<p>Using a Python API stub generated from UPBGE .rst documentation can solve both issues. In the <a class="reference internal" href="../tools/api_stubs.html#tools-api-stubs"><span class="std std-ref">API Stubs</span></a> chapter you can see how install the upbge-stubs package to improve the external editor experience.</p>
</section>
</section>
<section id="reference-material-and-documentation">
<h2>Reference Material and Documentation<a class="headerlink" href="#reference-material-and-documentation" title="Link to this heading"></a></h2>
<p>Since the <a class="reference external" href="https://upbge.org/docs/latest/api/index.html">UPBGE game engine Python API</a> is available online, you have an official excuse to keep a Web browser open while you work. It’s not a bad idea to keep an <a class="reference external" href="https://upbge.org/docs/latest/api/upbge-api-reference.zip">offline version of it</a>, too. Use it when you need to be more productive and the Internet is getting in your way (as in, always).</p>
<p>It’s good if you can start to gather example materials from the Internet and keep them organized. If you use the append feature in Blender to navigate to and import text files from your “collection”, you will not even need to open another Blender application. Also, if you are consistent with your naming style, indentation rules, and file structures, you will find easy to reuse your own scripts.</p>
</section>
<section id="testing-your-scripts">
<h2>Testing Your Scripts<a class="headerlink" href="#testing-your-scripts" title="Link to this heading"></a></h2>
<p>It doesn’t matter how easy Python is, you will spend evenings testing and retesting your scripts before you have them working properly. The more complete way to test your script is to play it inside the game engine. However, you may not want to load your game every time you need to be sure of some Python syntax, data types’ built-in functions, or simply to check if the math of a result is correct.</p>
<p>In those cases, you can use an interactive interpreter to help you. If you have Python installed on your system, you have it already. If you are using Windows, this will be the python.exe application in your Python installation directory (C:Python39by default, considering the installation of Python 3.9), as seen in Figure 7.8. In Linux or OSX, you have to type “python” in any console and you are good to go.</p>
<figure class="align-default" id="id5">
<img alt="../../_images/introduction_to_scripting_08.png" src="../../_images/introduction_to_scripting_08.png" />
<figcaption>
<p><span class="caption-text">Python IDE</span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>You can also use the UPBGE Python console. Change one of your current windows into the console, and you should see the screen shown in the next figure.</p>
<figure class="align-default" id="id6">
<img alt="../../_images/introduction_to_scripting_09.png" src="../../_images/introduction_to_scripting_09.png" />
<figcaption>
<p><span class="caption-text">UPBGE Python console</span><a class="headerlink" href="#id6" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Now you can use it to type simple codes, or to run a help or a dir into any of the Python modules. Unfortunately, only Blender modules have the auto-complete working from there.</p>
<p>Additionally, you can also use the in-game python console for debugging the game from python. In the scene properties tab you can activate it and set-up its short-cut.</p>
<figure class="align-default" id="id7">
<img alt="../../_images/introduction_to_scripting_10.png" src="../../_images/introduction_to_scripting_10.png" />
<figcaption>
<p><span class="caption-text">Set-up In-game UPBGE Python console</span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>To activate it, once the game has started you have to press the short-cut. Then the game will be paused and in the Windows console or linux terminal you will see the interactive python console, as you can see in the next figure. Whether you want to continue the game you need simply ending the interpreter, for Linux <kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">D</kbd> and for Windows <kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">Z</kbd> <kbd class="kbd docutils literal notranslate">&gt;</kbd> <kbd class="kbd docutils literal notranslate">Enter</kbd>.</p>
<figure class="align-default" id="id8">
<img alt="../../_images/introduction_to_scripting_11.png" src="../../_images/introduction_to_scripting_11.png" />
<figcaption>
<p><span class="caption-text">In-game UPBGE Python console</span><a class="headerlink" href="#id8" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Another important strategy is to keep the development of new functionalities outside the main file. For example, if you need to develop a navigation system (as we will soon), you don’t need to use your real big, high-textured scenario. Definitively not for the early tests. If you keep independent systems that work together, you will be able to identify errors faster and easier and even to port fixes over to other projects smoothly.</p>
<section id="designing-your-python-script-study-example">
<h3>Designing Your Python Script - Study Example<a class="headerlink" href="#designing-your-python-script-study-example" title="Link to this heading"></a></h3>
<p>We are now going to dive into an example of writing and planning a Python script for the game engine from scratch. We will assume that you have already covered all the basics of Python scripting and the general understanding of game engine internals so we can move on to its real usage. More specifically, we are going over the writing process of a camera navigation system for an architectural visualization walkthrough. This study case is actually the system developed for a commercial project for an Italian book project. In general, we needed to implement a system to navigate and interact in a virtual model of an Italian Doric temple. Here, however, we are going to develop it under a sandbox and reapply it into another file, emulating what you could do with your own projects.</p>
<p>Unlike gaming cameras, a virtual walkthrough can use a very simple navigation system compound of (1) an orbit mode to look at the exterior of the building; (2) a walk mode to navigate inside the building with gravity simulation and collision; (3) and a fly mode to freely explore the virtual environment with collision only. The other requirement was to make the system as portable as possible, and with the least amount of logic bricks.</p>
<p>All of those aspects must be considered from the first phases of the coding process. With a well-defined design, you can plan the most efficient system in the short and long run.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Pencil and Paper, Valuable Coding Assets</strong></p>
<p>It doesn’t matter how advanced and technical the coding is that you are working on; you can always have a great time sketching your ideas and plans with old-fashioned pencil and paper. This is how the problems are solved, clearly laying down the ideas and organizing them logically.</p>
</div>
<p>The system will consist of one camera for the orbit mode, and one to be used for both the fly and walk mode. Each mode works as described in the following table:</p>
<table class="docutils align-default" id="id9">
<caption><span class="caption-text">Comparison of Different Navigation Cameras</span><a class="headerlink" href="#id9" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Mode</p></th>
<th class="head"><p>Orbit</p></th>
<th class="head"><p>Walk</p></th>
<th class="head"><p>Fly</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Vertical Rotation Angle (Z)</p></td>
<td><p>-200º to 200º</p></td>
<td><p>Free</p></td>
<td><p>Free</p></td>
</tr>
<tr class="row-odd"><td><p>Horizontal Rotation Angle (X)</p></td>
<td><p>10º to 70º</p></td>
<td><p>-15º to 45º</p></td>
<td><p>Free</p></td>
</tr>
<tr class="row-even"><td><p>Moving Pivot</p></td>
<td><p>None</p></td>
<td><p>Empty</p></td>
<td><p>Empty</p></td>
</tr>
<tr class="row-odd"><td><p>Horizontal Rotation Pivot</p></td>
<td><p>Empty</p></td>
<td><p>Empty and Camera</p></td>
<td><p>Camera</p></td>
</tr>
<tr class="row-even"><td><p>Vertical Rotation Pivot</p></td>
<td><p>Empty</p></td>
<td><p>Empty</p></td>
<td><p>Empty</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p><strong>Empty:</strong> is an empty object the camera is parented to.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Try It Out</strong></p>
<p>In order to illustrate it better, you can see the working system demonstrated in the book file: BookChapter74_navigation_systemcamera_navigation.blend. To switch modes press 1, 2, or 3. This will change the mode to orbit, walk, and fly, respectively. To navigate, you can use the mouse and the keys <kbd class="kbd docutils literal notranslate">W</kbd> <kbd class="kbd docutils literal notranslate">A</kbd> <kbd class="kbd docutils literal notranslate">S</kbd> <kbd class="kbd docutils literal notranslate">D</kbd>.</p>
</div>
</section>
</section>
<section id="d-world-elements">
<h2>3D World Elements<a class="headerlink" href="#d-world-elements" title="Link to this heading"></a></h2>
<p>Open up the file BookChapter74_navigation_systemcamera_navigation.blend.</p>
<p>You will find two cameras and different empty objects in the first layer:</p>
<ul class="simple">
<li><p>scripts - an empty to calls all the scripts.</p></li>
<li><p>CAM_Move - the camera for the walk and fly mode.</p></li>
<li><p>CAM_Orbit - the camera for the orbit mode.</p></li>
<li><p>CAM_back, CAM_front, CAM_side, CAM_top - empties to store the position and orientation for the game cameras.</p></li>
<li><p>MOVE_PIVOT - the pivot for the walk and fly camera.</p></li>
<li><p>ORB_PIVOT - the pivot for the orbit camera.</p></li>
</ul>
<p>In the second layer, you will find the collision meshes[md]the ground and the vertical elements. Everything is very simple here, since we only need to test the system, and for that a few low poly obstacles work fine.</p>
</section>
<section id="understanding-the-code">
<h2>Understanding the Code<a class="headerlink" href="#understanding-the-code" title="Link to this heading"></a></h2>
<p>/Book/Chapter7/4_navigation_system/camera_navigation.py</p>
<p>This program is divided into five different parts:</p>
<ol class="arabic simple">
<li><p>Global Initialization;</p></li>
<li><p>Event Management;</p></li>
<li><p>Internal Functions;</p></li>
<li><p>Game Interaction;</p></li>
<li><p>More Python.</p></li>
</ol>
<p>The diagram in Figure 7.10 illustrates how they relate to one another. Now let’s take an inside look at each of them.</p>
<figure class="align-default" id="id10">
<img alt="../../_images/Fig07-10.png" src="../../_images/Fig07-10.png" />
<figcaption>
<p><span class="caption-text">Script architecture</span><a class="headerlink" href="#id10" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="global-initialization">
<h2>Global Initialization<a class="headerlink" href="#global-initialization" title="Link to this heading"></a></h2>
<p><cite>camera_navigation.init_world()</cite></p>
<p>There is one function that is loaded once at the beginning of the game; we call it <em>init_world</em> inside scripts.py. We are going to check the priority option in the Python controller to make sure this script runs on top of all the others. In this function, you will first find the global initialization. We are going to store in the global module logic all the elements we are going to reuse over the scripts. That way we don’t need to get the object list every time we need a particular object. A common technique is to store the scene object as well. Therefore, for every scene, you can run a script at the beginning of the game that stores a reference to the current scene globally:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">33</span> <span class="n">G</span><span class="o">.</span><span class="n">scenes</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;main&quot;</span><span class="p">:</span><span class="n">G</span><span class="o">.</span><span class="n">getCurrentScene</span><span class="p">()}</span>
<span class="mi">34</span> <span class="n">objects</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">scenes</span><span class="p">[</span><span class="s2">&quot;main&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">objects</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Save and Load a game with GlobalDict</strong></p>
<p>Since the module logic is accessible from all the functions and all the scenes, it can be used to store “global” objects. If you need to preserve those objects and variables between game sessions (i.e., after you close your game), you can store them inside the dictionary logic.globalDict and use logic.saveGlobalDict() and logic.loadGlobalDict() to save and load it.</p>
</div>
<p>To store the camera information, we are first going to create a global dictionary named cameras. We will use it to store the camera objects, their pivot, and the original orientation of the orbit pivot:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">43</span>     <span class="n">G</span><span class="o">.</span><span class="n">cameras</span> <span class="o">=</span> <span class="p">{}</span>
<span class="mi">44</span>     <span class="c1"># orbit camera</span>
<span class="mi">45</span>     <span class="n">camera</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="s2">&quot;CAM_Orbit&quot;</span><span class="p">]</span>
<span class="mi">46</span>     <span class="n">pivot</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="s2">&quot;ORB_PIVOT&quot;</span><span class="p">]</span>
<span class="mi">47</span>     <span class="n">G</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="s2">&quot;ORB&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">camera</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;orientation&quot;</span><span class="p">:</span><span class="n">pivot</span><span class="o">.</span><span class="n">worldOrientation</span><span class="p">},</span> <span class="n">pivot</span><span class="p">]</span>
<span class="mi">48</span>     <span class="c1"># fly/walk camera</span>
<span class="mi">49</span>     <span class="n">camera</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="s2">&quot;CAM_Move&quot;</span><span class="p">]</span>
<span class="mi">50</span>     <span class="n">pivot</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="s2">&quot;MOVE_PIVOT&quot;</span><span class="p">]</span>
<span class="mi">52</span>     <span class="n">G</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="s2">&quot;MOVE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">camera</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;orientation&quot;</span><span class="p">:</span><span class="n">pivot</span><span class="o">.</span><span class="n">worldOrientation</span><span class="p">,</span> <span class="s2">&quot;position&quot;</span><span class="p">:</span><span class="n">pivot</span><span class="o">.</span><span class="n">worldPosition</span><span class="p">},</span> <span class="n">pivot</span><span class="p">]</span>
</pre></div>
</div>
<p>Now that we have our objects instanced, we can set the initial values for our functions, such as the camera rotation restrictions. We don’t want the cameras to look under the ground; thus, we need to manually set our limits. Although we could set those limits directly in the orbit and look functions, having all the parameters in the same part of code is easier to tweak (and slightly faster since they don’t need to be reassigned every frame).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>External Settings File</strong></p>
<p>Another common workflow is to have a separate python file (for example, settings.py) with all the variables set. Then in your working script, you simply have to do: import settings.py and use e.g. settings.left.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>       <span class="c1"># Camera Orbit settings:</span>
<span class="mi">58</span>     <span class="c1"># angle restriction in degrees</span>
<span class="mi">59</span>     <span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="mf">220.0</span>
<span class="mi">60</span>     <span class="n">right</span> <span class="o">=</span> <span class="mf">220.0</span>
<span class="mi">61</span>     <span class="n">top</span> <span class="o">=</span> <span class="mf">70.0</span>
<span class="mi">62</span>     <span class="n">bottom</span> <span class="o">=</span> <span class="mf">10.0</span>
<span class="mi">63</span>
<span class="mi">64</span>     <span class="c1"># convert all of them to radians</span>
<span class="mi">65</span>     <span class="n">left</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="mi">70</span>     <span class="c1"># store them globally</span>
<span class="mi">71</span>     <span class="n">G</span><span class="o">.</span><span class="n">orb_limits</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:</span><span class="n">left</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span><span class="n">right</span><span class="p">,</span> <span class="s2">&quot;top&quot;</span><span class="p">:</span><span class="n">top</span><span class="p">,</span> <span class="s2">&quot;bottom&quot;</span><span class="p">:</span><span class="n">bottom</span><span class="p">}</span>
<span class="mi">72</span>
       <span class="c1"># Camera Walk/Fly settings:</span>
<span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>Last, but not least, we need to create the variables we are going to read and write between the functions. Initializing them here allows us to read them since the first frame of the game. This is especially important for variables that are going to be used in the event management functions - for different values of nav_mode and walk_fly, we are going to run different functions for the camera movement.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">103</span> <span class="n">G</span><span class="o">.</span><span class="n">walk_fly</span> <span class="o">=</span> <span class="s2">&quot;walk&quot;</span>
<span class="mi">104</span> <span class="n">G</span><span class="o">.</span><span class="n">nav_mode</span> <span class="o">=</span> <span class="s2">&quot;orbit&quot;</span>
</pre></div>
</div>
</section>
<section id="event-management">
<h2>Event Management<a class="headerlink" href="#event-management" title="Link to this heading"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">camera_navigation</span><span class="o">.</span><span class="n">mouse_move</span>
<span class="n">camera_navigation</span><span class="o">.</span><span class="n">keyboard</span>
</pre></div>
</div>
<p>Apart from the Always sensor needed for the <em>camera_navigation.init_world()</em> function, there are two other sensors we need - a keyboard and a mouse sensor. All the interaction you will have with this navigation system will run through those functions.</p>
<section id="scripts-mouse-move">
<h3>scripts.mouse_move<a class="headerlink" href="#scripts-mouse-move" title="Link to this heading"></a></h3>
<p>Let’s first take a look at the mouse sensor controlling system:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">210</span> <span class="k">def</span> <span class="nf">mouse_move</span><span class="p">(</span><span class="n">cont</span><span class="p">):</span>
<span class="mi">211</span>     <span class="n">owner</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">owner</span>
<span class="mi">212</span>     <span class="n">sensor</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">sensors</span><span class="p">[</span><span class="s2">&quot;s_movement&quot;</span><span class="p">]</span>
<span class="mi">213</span>
<span class="mi">214</span>     <span class="k">if</span> <span class="n">sensor</span><span class="o">.</span><span class="n">positive</span><span class="p">:</span>
<span class="mi">215</span>         <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="s2">&quot;CAM&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;ORB&quot;</span><span class="p">:</span>
<span class="mi">216</span>             <span class="n">orbit_camera</span><span class="p">(</span><span class="n">sensor</span><span class="p">)</span>
<span class="mi">217</span>         <span class="k">else</span><span class="p">:</span>
<span class="mi">218</span>             <span class="n">look_camera</span><span class="p">(</span><span class="n">sensor</span><span class="p">)</span>
</pre></div>
</div>
<p>It looks quite similar to the script template we saw recently. A difference is that instead of activating an actuator, we are calling a function to rotate the view. Actually, according to the current camera (orbit or fly/walk), we will have to call different functions (<em>orbit_camera</em> and <em>look_camera</em> respectively). Also, you can see that the function gets the controller passed as an argument. The game engine passes the controller by default for the module when using the Python Module controller. The argument declaration in the function is actually optional. So you could replace line 210 of the code with the following two lines, and it would work just as well:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mouse_move</span><span class="p">():</span>
    <span class="n">cont</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">getCurrentController</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="scripts-keyboard">
<h3>scripts.keyboard<a class="headerlink" href="#scripts-keyboard" title="Link to this heading"></a></h3>
<p>The second event management function handles keyboard inputs. This function takes the sensor input and calls internal functions according to the pressed key. If the pressed key is W, A, S, or D, we move the camera. If the key is 1, 2, or 3, we switch it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">110</span> <span class="k">def</span> <span class="nf">keyboard</span><span class="p">(</span><span class="n">cont</span><span class="p">):</span>
<span class="mi">111</span>     <span class="n">owner</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">owner</span>
<span class="mi">112</span>     <span class="n">sensor</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">sensors</span><span class="p">[</span><span class="s2">&quot;s_keyboard&quot;</span><span class="p">]</span>
<span class="mi">113</span>
<span class="mi">114</span>     <span class="k">if</span> <span class="n">sensor</span><span class="o">.</span><span class="n">positive</span><span class="p">:</span>
<span class="mi">115</span>         <span class="n">keylist</span> <span class="o">=</span> <span class="n">sensor</span><span class="o">.</span><span class="n">events</span>
<span class="mi">117</span>         <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keylist</span><span class="p">:</span>
<span class="mi">118</span>             <span class="n">value</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">119</span>
<span class="mi">120</span>             <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="s2">&quot;CAM&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;MOVE&quot;</span><span class="p">:</span>
<span class="mi">121</span>                 <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">GK</span><span class="o">.</span><span class="n">WKEY</span><span class="p">:</span>
<span class="mi">122</span>                     <span class="c1"># Move Forward</span>
<span class="mi">123</span>                     <span class="n">move_camera</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="mi">124</span>                <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="n">GK</span><span class="o">.</span><span class="n">SKEY</span><span class="p">:</span>
<span class="mi">125</span>                    <span class="c1"># Move Backward</span>
<span class="mi">126</span>                     <span class="n">move_camera</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">127</span>                 <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="n">GK</span><span class="o">.</span><span class="n">AKEY</span><span class="p">:</span>
<span class="mi">128</span>                     <span class="c1"># Move Left</span>
<span class="mi">129</span>                     <span class="n">move_camera</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">130</span>                 <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="n">GK</span><span class="o">.</span><span class="n">DKEY</span><span class="p">:</span>
<span class="mi">131</span>                     <span class="c1"># Move Right</span>
<span class="mi">132</span>                     <span class="n">move_camera</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">133</span>
<span class="mi">134</span>            <span class="c1"># CAMERA SWITCHING</span>
<span class="mi">135</span>            <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">GK</span><span class="o">.</span><span class="n">ONEKEY</span><span class="p">:</span>
<span class="mi">136</span>                <span class="n">change_view</span><span class="p">(</span><span class="s2">&quot;orbit&quot;</span><span class="p">,</span> <span class="s2">&quot;orbit&quot;</span><span class="p">)</span>
<span class="mi">137</span>            <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="n">GK</span><span class="o">.</span><span class="n">TWOKEY</span><span class="p">:</span>
<span class="mi">138</span>                <span class="n">change_view</span><span class="p">(</span><span class="s2">&quot;front&quot;</span><span class="p">)</span>
<span class="mi">139</span>            <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="n">GK</span><span class="o">.</span><span class="n">THREEKEY</span><span class="p">:</span>
<span class="mi">140</span>                <span class="n">change_view</span><span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="s2">&quot;fly&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>For a World with Fewer Logic Bricks</strong></p>
<p>If you don’t want to use a keyboard sensor, you can use an internal instance of the keyboard module. You can read about this in the “bge.logic API” section later in this chapter, or on the online API page: _http://www.blender.org/documentation/blender_python_api_2_66_release/bge.logic.html#bge.logic.keyboard._</p>
</div>
</section>
</section>
<section id="internal-functions">
<h2>Internal Functions<a class="headerlink" href="#internal-functions" title="Link to this heading"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scripts</span><span class="o">.</span><span class="n">move_camera</span>
<span class="n">scripts</span><span class="o">.</span><span class="n">orbit_camera</span>
<span class="n">scripts</span><span class="o">.</span><span class="n">look_camera</span>
</pre></div>
</div>
<p>These three functions are called from the event management functions. In their lines, you can find the math responsible for the camera movement. We’re calling them “internal functions” because they are the bridge between the sensors’ inputs and the outputs in the game engine world.</p>
<section id="scripts-move-camera">
<h3>scripts.move_camera<a class="headerlink" href="#scripts-move-camera" title="Link to this heading"></a></h3>
<p>The function responsible for the camera movement is very simple. In the walk and fly mode, we are going to move the pivot in the desired direction (which is passed as argument). Therefore, we first need to create a vector to this course. If you are unfamiliar with vectorial math, think of vector as the direction between the origin [0, 0, 0] and the vector coordinates [X, Y, Z].</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">336</span> <span class="k">def</span> <span class="nf">move_camera</span><span class="p">(</span><span class="n">direction</span><span class="p">):</span>
<span class="mi">338</span>     <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="s2">&quot;CAM&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;MOVE&quot;</span><span class="p">:</span> <span class="k">return</span>
<span class="mi">339</span>     <span class="n">MOVE</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="c1"># speed</span>
<span class="mi">340</span>
<span class="mi">341</span>     <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Forward</span>
<span class="mi">342</span>         <span class="n">vector</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">MOVE</span><span class="p">])</span>
<span class="mi">344</span>     <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Backward</span>
<span class="mi">345</span>         <span class="n">vector</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MOVE</span><span class="p">])</span>
<span class="mi">347</span>     <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># Left</span>
<span class="mi">348</span>         <span class="n">vector</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="o">-</span><span class="n">MOVE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="mi">350</span>     <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># Right</span>
<span class="mi">351</span>         <span class="n">vector</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="n">MOVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="mi">356</span>     <span class="c1"># now that we calculated the vector we can move the pivot</span>
<span class="mi">357</span>     <span class="c1"># to be continued in the Game Interaction section</span>
</pre></div>
</div>
<p>Here the vector is the movement we need to apply to the pivot in order to get it moving. The size of the vector (MOVE) will act as intensity or speed of the movement.</p>
</section>
<section id="scripts-orbit-camera">
<h3>scripts.orbit_camera<a class="headerlink" href="#scripts-orbit-camera" title="Link to this heading"></a></h3>
<p>We decided to use different methods for the walk/fly camera and the orbit one. In the orbit camera, every position on the screen corresponds to an orientation of the camera.</p>
<p>If you want to study this part of the script in particular, you can turn on the Mouse Cursor in the Render Panel. That way, you can see that the same cursor position will (or should) always generate the same view.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">224</span> <span class="k">def</span> <span class="nf">orbit_camera</span><span class="p">(</span><span class="n">sensor</span><span class="p">):</span>
<span class="mi">228</span>     <span class="c1"># Get screen size, attributes from the sensor and global variables</span>
<span class="mi">229</span>     <span class="n">screen_width</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">getWindowWidth</span><span class="p">()</span>
<span class="mi">230</span>     <span class="n">screen_height</span><span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">getWindowHeight</span><span class="p">()</span>
<span class="mi">231</span>
<span class="mi">232</span>     <span class="n">win_x</span><span class="p">,</span> <span class="n">win_y</span> <span class="o">=</span> <span class="n">sensor</span><span class="o">.</span><span class="n">position</span>
<span class="mi">233</span>
<span class="mi">234</span>     <span class="c1"># G.orb_clamp is in radians</span>
<span class="mi">235</span>     <span class="n">orb_limits</span>   <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">orb_limits</span>
<span class="mi">236</span>     <span class="n">left_limit</span>   <span class="o">=</span> <span class="n">orb_limits</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span>
<span class="mi">237</span>     <span class="n">right_limit</span>  <span class="o">=</span> <span class="n">orb_limits</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span>
<span class="mi">238</span>     <span class="n">bottom_limit</span> <span class="o">=</span> <span class="n">orb_limits</span><span class="p">[</span><span class="s2">&quot;bottom&quot;</span><span class="p">]</span>
<span class="mi">239</span>     <span class="n">top_limit</span>    <span class="o">=</span> <span class="n">orb_limits</span><span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">]</span>
<span class="mi">240</span>
<span class="mi">241</span>     <span class="c1"># Normalizing x to run from left to right limits</span>
<span class="mi">242</span>     <span class="n">x</span> <span class="o">=</span> <span class="n">win_x</span> <span class="o">/</span> <span class="n">screen_width</span>
<span class="mi">243</span>     <span class="n">x</span> <span class="o">=</span> <span class="n">left_limit</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">right_limit</span> <span class="o">-</span> <span class="n">left_limit</span><span class="p">))</span>
<span class="mi">244</span>
<span class="mi">245</span>     <span class="c1"># Normalize y to run from top to bottom limits</span>
<span class="mi">246</span>     <span class="n">y</span> <span class="o">=</span> <span class="n">win_y</span> <span class="o">/</span> <span class="n">screen_height</span>
<span class="mi">247</span>     <span class="n">y</span> <span class="o">=</span> <span class="n">top_limit</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">bottom_limit</span> <span class="o">-</span> <span class="n">top_limit</span><span class="p">))</span>
<span class="mi">248</span>
<span class="mi">249</span>     <span class="c1"># Flip the vertical movement</span>
<span class="mi">250</span>     <span class="n">y</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span>
<span class="mi">251</span>
<span class="mi">254</span>     <span class="c1"># Calculate the new orientation matrix</span>
<span class="mi">255</span>     <span class="n">mat_ori</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="s2">&quot;ORB&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span>
<span class="mi">256</span>
<span class="mi">257</span>     <span class="n">mat_x</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">Rotation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">)</span>
<span class="mi">258</span>     <span class="n">mat_y</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">Rotation</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="mi">259</span>
<span class="mi">260</span>     <span class="n">ori</span> <span class="o">=</span> <span class="n">mat_x</span> <span class="o">*</span> <span class="n">mat_y</span>
<span class="mi">261</span>
<span class="mi">262</span>     <span class="c1"># now we can use ori as our new orientation matrix</span>
<span class="mi">264</span>     <span class="c1"># to be continued in the Game Interaction section</span>
<span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The first lines that deserve our attention here are the normalizing operation. To normalize a value means to convert it to a range from 0.0 to 1.0.  In our case, it can be understood as the mouse pointer coordinates relative to the screen dimensions (width and height):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">242</span>     <span class="n">x</span> <span class="o">=</span> <span class="n">win_x</span> <span class="o">/</span> <span class="n">screen_width</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Even Fewer Logic Bricks and Normalized Mouse Coordinates</strong></p>
<p>It’s important to always use normalized coordinates for your screen operations. Otherwise, different desktop resolutions will produce different results in a game. As a counter edge case, you may need the absolute coordinates for mouse events if you want to assure minimum clickable areas for your events. You don’t always need to normalize the mouse coordinates manually. Like the keyboard sensor, you can replace the mouse sensor by an internal instance of the mouse module. The coordinates from bge.logic.mouse run from 0.0 to 1.0 and can be read anytime. (You can even link your script to an Always sensor, leaving the Mouse sensor for the times where you are using more logic bricks.) You can read about this in the “bge.logic API” section in this chapter or on the online API page: _http://www.blender.org/documentation/blender_python_api_2_66_release/bge.logic.html#bge.logic.keyboard_</p>
</div>
<p>Now a simple operation to convert the normalized value into a value inside our horizontal angle range (-220º to 220º):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">243</span>     <span class="n">x</span> <span class="o">=</span> <span class="n">left_limit</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">right_limit</span> <span class="o">-</span> <span class="n">left_limit</span><span class="p">))</span>
</pre></div>
</div>
<p>We run the same operation for the vertical coordinate of the mouse. Though you must be aware that the canvas height runs from the top (0) to the bottom (height), this is different from what we could expect (or from OpenGL coordinates, for example). In order to better understand the flipping operation (line 257), you can first comment/uncomment the code to see the difference.</p>
<p>Next find in the .blend file the pivot empty (ORB_PIVOT) and play with its rotation in the X axis. The rotation is demonstrated in Figure 7.11. Therefore, if we subtract our angle from 90º (__PI__/2 in radians), we get the proper angle to rotate the pivot vertically.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">250</span>    <span class="n">y</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="err">–</span> <span class="n">y</span>
</pre></div>
</div>
<figure class="align-default" id="id11">
<img alt="../../_images/Fig07-11.png" src="../../_images/Fig07-11.png" />
<figcaption>
<p><span class="caption-text">Orbit pivot rotation</span><a class="headerlink" href="#id11" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="scripts-look-camera">
<h3>scripts.look_camera<a class="headerlink" href="#scripts-look-camera" title="Link to this heading"></a></h3>
<p>The function to rotate the walk/fly camera is quite different from the orbit one. We don’t have a direct relation between mouse coordinate and camera rotation anymore. Here we get the relative position of the cursor (from the center) and later force the mouse to be re-centered[md]to avoid continuous movement unless the mouse is moved again.</p>
<p>In order to get the relative position of the cursor, the normalizing function needs to be different. This time we want the center of the screen to be 0.0 and the extreme edges of the canvas (border of the game window) to be -0.5 and 0.5.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">291</span>     <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">win_x</span> <span class="o">/</span> <span class="n">screen_width</span><span class="p">)</span>  <span class="o">-</span> <span class="mf">0.5</span>
<span class="mi">292</span>     <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">win_y</span> <span class="o">/</span> <span class="n">screen_height</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
</pre></div>
</div>
<p>The values of x and y can be used directly as radians angles to rotate the camera. However, when we are walking, we want to restrict the view vertically. This design decision means that we need to limit the view angle to a maximum and minimum range. Sure, this turns tying your shoes into a circus challenge. Though it may seem like overkill, this limitation helps add a better sense of reality to our navigation system.</p>
<p>The solution is to get the current camera vertical angle and see if by adding the new angle  (i.e., vertical mouse move) we would end up over the limit of 45º. If so, we clamp the new angle to respect this value. To get the vertical angle, remember that the camera pivot (an empty object) is always parallel to the ground. Therefore, the vertical angle can be extracted from the camera’s local orientation matrix. If that still doesn’t make sense to you, try to find some 3D math tutorials online).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">302</span>     <span class="c1"># limit top - bottom angles</span>
<span class="mi">303</span>     <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">walk_fly</span> <span class="o">==</span> <span class="s2">&quot;walk&quot;</span><span class="p">:</span>
<span class="mi">304</span>         <span class="n">angle</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">localOrientation</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">305</span>         <span class="n">angle</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
<span class="mi">306</span>
<span class="mi">307</span>     <span class="c1"># if it&#39;s too high go down. if it&#39;s too low go high</span>
<span class="mi">308</span>         <span class="k">if</span> <span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">top_limit</span><span class="p">:</span> <span class="n">y</span> <span class="o">=</span> <span class="n">top_limit</span> <span class="o">-</span> <span class="n">angle</span>
<span class="mi">309</span>         <span class="k">elif</span> <span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bottom_limit</span><span class="p">:</span> <span class="n">y</span> <span class="o">=</span> <span class="n">bottom_limit</span> <span class="o">-</span> <span class="n">angle</span>
</pre></div>
</div>
<p>For the actual project this was originally designed for, we ended up moving the orbit camera code to be a subset of the walk/fly. Having the mouse always centered comes in handy when you have a user interface on top of that, and it needs to alternate between mouse clicking and camera rotating. Although the methods are different, the results are the same.</p>
</section>
</section>
<section id="game-interaction">
<h2>Game Interaction<a class="headerlink" href="#game-interaction" title="Link to this heading"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">camera_navigation</span><span class="o">.</span><span class="n">change_view</span>
</pre></div>
</div>
<p>And the outcome of the functions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">camera_navigation</span><span class="o">.</span><span class="n">move_camera</span>
<span class="n">camera_navigation</span><span class="o">.</span><span class="n">look_camera</span>
<span class="n">camera_navigation</span><span class="o">.</span><span class="n">orbit_camera</span>
</pre></div>
</div>
<p>In the previous section, we saw how the angles and directions were calculated with Python. However, we deliberately skipped the most important part: applying it to the game engine elements. It includes activating actuators (as we do in the change_view() function) or directly interfering in our game elements (cameras and pivots).</p>
<section id="outcome-of-the-functions-scripts-move-camera-scripts-look-camera-and-scripts-orbit-camera">
<h3>Outcome of the functions: scripts.move_camera, scripts.look_camera, and scripts.orbit_camera<a class="headerlink" href="#outcome-of-the-functions-scripts-move-camera-scripts-look-camera-and-scripts-orbit-camera" title="Link to this heading"></a></h3>
<p>Let’s put the pieces together now. We already know the camera future orientation and position. Therefore, there is almost nothing left to be calculated here. Nevertheless, there are distinct ways to change the object position and orientation.</p>
<p>In move_camera(), we are going to use an instance method of the pivot object called applyMovement (vector, local). This is part of the game engine methods (another one is applyRotation you will see next) we explain later in this chapter in the “Using the Game Engine API” section. This built-in function translates the object using the vector passed as a parameter. It can either be relative to the local or world coordinates:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">336</span> <span class="k">def</span> <span class="nf">move_camera</span><span class="p">(</span><span class="n">direction</span><span class="p">):</span>
<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="mi">356</span>     <span class="c1"># now that we calculated the vector we can move the pivot</span>
<span class="mi">357</span>     <span class="n">pivot</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="s2">&quot;MOVE&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">358</span>     <span class="n">pivot</span><span class="o">.</span><span class="n">applyMovement</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In a similar way in the look_camera() function, we will apply the rotation in the camera object. This has the advantage of sparing the hassles of 3D math, matrixes, and orientations. Also, instead of manually computing the new orientation matrix in Python, we can rely on the game engine C++ native (i.e., fast) implementation for that task.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">269</span> <span class="k">def</span> <span class="nf">look_camera</span><span class="p">(</span><span class="n">sensor</span><span class="p">):</span>
<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="mi">314</span>     <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">walk_fly</span> <span class="o">==</span> <span class="s2">&quot;walk&quot;</span><span class="p">:</span>
<span class="mi">315</span>         <span class="c1"># Look Up rotation</span>
<span class="mi">316</span>         <span class="n">camera</span><span class="o">.</span><span class="n">applyRotation</span><span class="p">([</span><span class="n">y</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">317</span>
<span class="mi">318</span>         <span class="c1"># Look Side rotation</span>
<span class="mi">319</span>         <span class="n">pivot</span><span class="o">.</span><span class="n">applyRotation</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Although we are leaving the math calculation to the game engine, we should still be aware of how it works. The applyRotation() routine works with Euler angles (as a gimbal machine). The effects for the walk and the fly modes are very similar. The only difference is whether the rotation is local or global and the axis to rotate around:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">322</span>     <span class="k">else</span><span class="p">:</span> <span class="c1"># G.walk_fly == &quot;fly&quot;</span>
<span class="mi">323</span>         <span class="c1"># Look Side rotation</span>
<span class="mi">324</span>         <span class="n">pivot</span><span class="o">.</span><span class="n">applyRotation</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">325</span>
<span class="mi">326</span>         <span class="c1"># Look Up rotation</span>
<span class="mi">327</span>         <span class="n">pivot</span><span class="o">.</span><span class="n">applyRotation</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In the orbit_camera() function, we calculated the orientation matrix of the pivot. This matrix is no more than a fancy mathematical way of describing a rotation. Since we already have the matrix, all we need to do is to set it to our pivot orientation.</p>
<p>The orientation is a Python built-in variable that can be read and written directly by our script. We will talk more about this in the “Using the Game Engine API - Application Programming Interface” part of this chapter.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">223</span> <span class="k">def</span> <span class="nf">orbit_camera</span><span class="p">(</span><span class="n">sensor</span><span class="p">):</span>
<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="mi">261</span>     <span class="c1"># now we can use ori as our new orientation matrix</span>
<span class="mi">262</span>     <span class="n">pivot</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="s2">&quot;ORB&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">263</span>     <span class="n">pivot</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">ori</span>
</pre></div>
</div>
</section>
<section id="scripts-change-view">
<h3>scripts.change_view<a class="headerlink" href="#scripts-change-view" title="Link to this heading"></a></h3>
<p>After the user presses a key (1, 2, or 3) to change the view, we call the change_view() function to switch to the new camera (with a parameter specifying which camera to use). This function consists of two parts: first, we set the correct position and orientation for the camera and pivot; secondly, we change the current camera to the new one.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Decomposing the View Orientation</strong></p>
<p>Keep in mind that the desired orientation (stored in the empty and accessed through the G.views dictionary) represents the new view orientation. In our system, this view orientation is the combination of the parent object (pivot) orientation with the child one (camera).</p>
</div>
<p>Let’s start simple and build up as we go. First the orbit camera: in the orbit mode the camera is stationary[md]its position never changes. All we need to do is reset the pivot orientation to its initial values. Its orientation was globally stored back in the init_world() function. So now we can retrieve and apply it to the pivot:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">155</span>         <span class="nb">dict</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="s2">&quot;ORB&quot;</span><span class="p">]</span>
<span class="mi">157</span>         <span class="n">pivot</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">158</span>         <span class="n">pivot</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>The fly camera is slightly different. In this case, the camera orientation contains no rotation (i.e., an identity matrix). Therefore, it’s up to the pivot orientation to match the view orientation. In other words, the pivot orientation matrix is exactly the same as the view orientation matrix:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">169</span>         <span class="n">pivot</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">views</span><span class="p">[</span><span class="n">view</span><span class="p">]</span><span class="o">.</span><span class="n">position</span>
<span class="mi">170</span>         <span class="n">pivot</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">views</span><span class="p">[</span><span class="n">view</span><span class="p">]</span><span class="o">.</span><span class="n">orientation</span>
<span class="mi">171</span>         <span class="n">camera</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>

<span class="mi">177</span>         <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">walk_fly</span> <span class="o">==</span> <span class="s2">&quot;walk&quot;</span><span class="p">:</span>
<span class="mi">178</span>             <span class="n">fly_to_walk</span><span class="p">()</span>
</pre></div>
</div>
<p>For the walk camera, we have yet another situation. The mode we are coming from (fly) has the camera pivot orientation (same as camera.worldOrientation) as the current view orientation.  However, for the walk mode, the pivot needs to be parallel to the ground.</p>
<p>For that, we need to rotate it a few degrees to align with the horizon. The camera now will be looking to a different point (above/below the original direction). In order to realign the camera with the view orientation, we need to rotate the camera in the opposite direction. This way, the pivot and camera rotations void each other (with the benefit of having the pivot now properly aligned with the ground).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">190</span> <span class="k">def</span> <span class="nf">fly_to_walk</span><span class="p">():</span>
<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="mi">194</span>     <span class="n">view_orientation</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">worldOrientation</span>
<span class="mi">195</span>     <span class="n">euler</span> <span class="o">=</span> <span class="n">view_orientation</span><span class="o">.</span><span class="n">to_euler</span><span class="p">()</span>
<span class="mi">196</span>     <span class="n">angle</span> <span class="o">=</span> <span class="n">euler</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">197</span>
<span class="mi">198</span>     <span class="n">pivot</span><span class="o">.</span><span class="n">applyRotation</span><span class="p">([</span><span class="o">-</span><span class="n">angle</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">199</span>     <span class="n">camera</span><span class="o">.</span><span class="n">applyRotation</span><span class="p">([</span><span class="n">angle</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Reasoning Behind the Design</strong></p>
<p>There is another reason for keeping this as a separate function. Originally, I was planning to switch modes (walk/fly) while keeping the same camera position and view. Although I dropped the idea, I decided to keep the system flexible in case of any turn of events (clients who understands their minds?).</p>
</div>
<p>Now that the new camera and pivot have the correct position and orientation, we can effectively switch cameras. For that, we first set the new camera in the Scene Set Camera actuator. Next, we activate the actuator and the camera will change:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">181</span>     <span class="n">act_camera</span><span class="o">.</span><span class="n">camera</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">182</span>     <span class="n">cont</span><span class="o">.</span><span class="n">activate</span><span class="p">(</span><span class="n">act_camera</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="more-python">
<h2>More Python<a class="headerlink" href="#more-python" title="Link to this heading"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scripts</span><span class="o">.</span><span class="n">collision_check</span>
<span class="n">scripts</span><span class="o">.</span><span class="n">stick_to_ground</span>
</pre></div>
</div>
<p>The script system shown so far handles all the interaction from the game engine sensors to the 3D world elements. Even though this covers most parts of a typical script architecture, I’d be lying if I said this is all you will be doing in your projects. Very often, you will need a script called once in a while that deals directly with the game engine data. In our case, we will have two “PySensors” to control the collision and to stick our camera to the ground while walking.</p>
<p>We could have them both working attached to an Always sensor. However, this would not be too efficient. Since we only need them while walking and flying, they can be integrated with the Keyboard sensor pipeline. The stick_to_ground() function will be called after any key is pressed if the current mode is “walk”:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">142</span>         <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">nav_mode</span> <span class="o">==</span> <span class="s2">&quot;walk&quot;</span> <span class="ow">and</span> <span class="n">G</span><span class="o">.</span><span class="n">walk_fly</span> <span class="o">==</span> <span class="s2">&quot;walk&quot;</span><span class="p">:</span>
<span class="mi">143</span>             <span class="n">stick_to_ground</span><span class="p">()</span>
</pre></div>
</div>
<p>The collision system can be used even more specifically. Inside the move_camera() function, we will use the collision test to validate or discard our moving vector:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">353</span>         <span class="c1"># if there is any obstacle reset the vector</span>
<span class="mi">354</span>         <span class="n">vector</span> <span class="o">=</span> <span class="n">collision_check</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
</pre></div>
</div>
<p>If the collision_check() test finds any obstacle in front of the camera, it returns a null vector ([0, 0, 0]). Otherwise, it leaves the vector as it was set, which will then move the camera.</p>
<p>The code of those functions is very particular to this project; therefore, we’re not going into more detail here. (You are encouraged to take a look at the complete code in the book file, though). Nevertheless, the key point is to understand the role of those functions in the script architecture. Those scripts can complement the functionality of other functions, to rule your game in a global and direct way, or simply to tie things together.</p>
</section>
<section id="reusing-your-script">
<h2>Reusing Your Script<a class="headerlink" href="#reusing-your-script" title="Link to this heading"></a></h2>
<p>One of the reasons this system was designed so carefully is because of the need for portability. You don’t want to rewrite a navigation system every time you have a new project. This is not particular to this script example. Very often, you will be recycling your own scripts to adapt them to new files. Let’s go over some principles you should know.</p>
</section>
<section id="file-organization-groups-and-layers">
<h2>File Organization - Groups and Layers<a class="headerlink" href="#file-organization-groups-and-layers" title="Link to this heading"></a></h2>
<p>The first thing to have in mind is how your final file will look. Do you want the script system to be merged with the rest of the existent Blender file? Do you want to keep them in separated scenes (very common for user interfaces)? Will you need to access/edit the script system elements later?</p>
<p>In our case, there is no need for an extra scene. However, we need to make sure that the navigation system elements are easy to access (especially the empties with the cameras’ positions). If you can afford to dedicate one layer exclusively to the navigation system elements, do it. Make sure that the desired layer is empty in the model file and that all the objects you want to import are contained in this layer.</p>
<p>If it’s not possible to have all your elements in a single layer, you can create a group for them. That way, you can always quickly isolate them to be listed in the outliner and selected individually. The other advantage of using groups is during importing. It’s easier to select a group to be imported than to go over all the individual objects, determining which one should be imported and which one is part of the test environment (which usually doesn’t have to be imported).</p>
</section>
<section id="tweaks-and-adjustments-getting-your-hands-dirty">
<h2>Tweaks and Adjustments - Getting Your Hands Dirty<a class="headerlink" href="#tweaks-and-adjustments-getting-your-hands-dirty" title="Link to this heading"></a></h2>
<p>Open the file /Book/Chapter7/4_navigation_system/walkthrough_1_base/walkthrough.blend</p>
<p>This small file is part of the presentation of an architectural walkthrough of an urban project (see Figure 7.12) that I (Dalai) did. It’s an academic project and only my second project using the game engine. As you can see, there are absolutely no scripts in it[md]all the interaction is done with logic bricks. I didn’t use Python for this project mainly because I had absolutely no knowledge of Python at all back then (and the project was done in six days).</p>
<figure class="align-default" id="id12">
<img alt="../../_images/Fig07-12.png" src="../../_images/Fig07-12.png" />
<figcaption>
<p><span class="caption-text">Architectural walkthrough example file</span><a class="headerlink" href="#id12" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>It’s time for redemption. Let’s replace its navigation system with the Python system we just studied. For convenience, this file was already organized to receive the navigation elements (cameras, empties, and so on.).</p>
<section id="organize-and-append-your-file">
<h3>Organize and Append Your File<a class="headerlink" href="#organize-and-append-your-file" title="Link to this heading"></a></h3>
<p>In this case, we decided to group all the navigation elements in a group called NAVIGATIONSYSTEM and to make sure they are all in layer 1. You can use the Outliner to make sure you didn’t miss any object out of the group. Leave the lamps and the collision objects out of the group.</p>
<p>To see a snapshot of the file at this moment, you can find it in the book files at: /Book/Chapter7/4_navigation_system/walkthrough_2_partial/camera_navigation.blend</p>
<p>Now open the walkthrough file again and append the NAVIGATIONSYSTEMwe created. It’s important not to link the group but to append it. Linked elements can only be moved in their original files; thus, you should avoid them in this case.</p>
<ol class="arabic simple">
<li><p>Open the Append Objects Dialog (Shift+F1).</p></li>
<li><p>Find the NAVIGATIONSYSTEM group inside the camera_navigation file.</p></li>
<li><p>Make sure the option “Instance Groups” is not checked. (This would insert the group, not the individual elements.)</p></li>
<li><p>Click on the “Link/Append from Library”. (This will add the group.)</p></li>
<li><p>Set CAM_Orbit as the default camera. (Tip: Use the Outliner to find the object; it’s inside the ORB_PIVOT.)</p></li>
</ol>
<p>A snapshot with those changes can be found at:</p>
<p>/Book/Chapter7/4_navigation_system/walkthrough_2_partial/walkthrough.blend</p>
<p>Now if you run the application, the navigation system should work - kind of (see Figure 7.13).</p>
<figure class="align-default" id="id13">
<img alt="../../_images/Fig07-13.png" src="../../_images/Fig07-13.png" />
<figcaption>
<p><span class="caption-text">Still not there</span><a class="headerlink" href="#id13" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="adjustments-in-loco">
<h3>Adjustments in Loco<a class="headerlink" href="#adjustments-in-loco" title="Link to this heading"></a></h3>
<p>As you can see in Figure 7.13, the new camera system looks absurdly wrong. There are two main reasons for that: the walkthrough file elements are far away from the file origin [0, 0, 0], and the cameras are not prepared for a project with this magnitude (their clipping parameters are way too low). We will need to move the objects to their new correct places, adjust the camera parameters, and do a small intervention in the script file:</p>
<p>All the elements from NAVIGATIONSYSTEM group (layer 1):</p>
<p>Move them 2000 in X and 350 in Y.</p>
<p><strong>Empties</strong> :</p>
<ul class="simple">
<li><p>CAM_front and CAM_back - Those empties will hold the position for walk cameras. Make sure their position from the ground is at the human eyes (~1.68).</p></li>
<li><p>CAM_top and CAM_side - Those empties will be used in Fly Mode. Here, we should also make sure their initial orientation looks good. The easiest way to do that is by using the Fly Mode (select the object, set it as current camera, and use Shift+F).</p></li>
</ul>
<p>The one thing missing for the camera is to increase the clipping distance. That way, we can see all the skydome around the camera (see before and after in Figure 7.14).</p>
<p><strong>Cameras</strong> :</p>
<ul class="simple">
<li><p>CAM_Orbit - Adjust initial Z, change clip ending to 1000.</p></li>
<li><p>CAM_Move - change clip ending to 1000.</p></li>
</ul>
<p>A snapshot with those changes can be found at:</p>
<p>/Book/Chapter7/4_navigation_system/walkthrough_3_partial/walkthrough.blend</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Camera clipping of 400</p></th>
<th class="head"><p>Camera clipping of 1000</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><figure class="align-default">
<img alt="../../_images/Fig07-14a.png" src="../../_images/Fig07-14a.png" />
</figure>
</td>
<td><figure class="align-default">
<img alt="../../_images/Fig07-14b.png" src="../../_images/Fig07-14b.png" />
</figure>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Make Sure That Collision Is Set Properly</strong></p>
<p>All the houses, the ground, and the other 3D objects already have collision enabled in this file. In other situations, however, you may need to change the collision objects, enabling or disabling their collisions accordingly. The Python raycast uses the internal Bullet Physics engine under the hood. In order to prevent the camera from going through the walls and the ground, set enough collision surfaces (but not too much, so that you don’t compromise the performance of your game).</p>
</div>
</section>
<section id="script-tweaks">
<h3>Script Tweaks<a class="headerlink" href="#script-tweaks" title="Link to this heading"></a></h3>
<p>Finally, it’s good to fiddle a bit with the script. Due to the particularities of this project (mainly its scale), you may feel that everything happens a bit too fast. It’s up to you to change the settings in the <cite>init_world</cite> function. Also, it would be interesting to explore multiple viewpoints for this presentation. We have already positioned the side and back empties. Although we were not using them previously, their names are present in the script as part of the available cameras list:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">93</span>     <span class="n">available_cameras</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;front&quot;</span><span class="p">,</span> <span class="s2">&quot;back&quot;</span><span class="p">,</span> <span class="s2">&quot;side&quot;</span><span class="p">,</span> <span class="s2">&quot;top&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>The difference now is that we will make the camera actually change to the side and back views when you press the keys four and five respectively. As you can see here, it’s really easy to expand a system like this. Try to create a fifth camera (add a new empty) and see how it goes. To enable the “side” and “back” cameras, the only code we have to add is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">110</span> <span class="k">def</span> <span class="nf">keyboard</span><span class="p">(</span><span class="n">cont</span><span class="p">):</span>
<span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">new</span>             <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="n">GK</span><span class="o">.</span><span class="n">FOURKEY</span><span class="p">:</span>
<span class="n">new</span>                 <span class="n">change_view</span><span class="p">(</span><span class="s2">&quot;side&quot;</span><span class="p">)</span>
<span class="n">new</span>             <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="n">GK</span><span class="o">.</span><span class="n">FIVEKEY</span><span class="p">:</span>
<span class="n">new</span>                 <span class="n">change_view</span><span class="p">(</span><span class="s2">&quot;back&quot;</span><span class="p">,</span> <span class="s2">&quot;fly&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>There is not much more to be done here. This is a simple script, but its structure and the workflow we presented are not much different from what you will find in more complex systems you may have to implement or work with. There are different ways to implement a navigation system. This one was designed focusing on a didactic structure (clean code as opposed to a highly optimized system that is hard to read) and robustness (easy to expand). Try to find other examples or, better yet, build one yourself.</p>
<p>The final file is on the book files as:</p>
<p>/Book/Chapter7/4_navigation_system/walkthrough_4_final/walkthrough.blend.</p>
</section>
</section>
<section id="using-the-game-engine-api-application-programming-interface">
<h2>Using the Game Engine API - Application Programming Interface<a class="headerlink" href="#using-the-game-engine-api-application-programming-interface" title="Link to this heading"></a></h2>
<p>The game engine API is a bridge connecting your Python scripts with your game data. Through those modules, methods, and variables you can interact with your existent logic bricks, game objects, and general game functions.</p>
<p>The official documentation can be found online in the Blender Foundation website (TODO to be changed):</p>
<p><a class="reference external" href="http://www.blender.org/documentation/blender_python_api_2_66_release">http://www.blender.org/documentation/blender_python_api_2_66_release</a></p>
<p>We will now walk through the highlights of the modules. After you are familiar with their main functionality, you should feel comfortable to navigate the documentation and find other resources.</p>
<p><strong>Game Engine Internal Modules</strong></p>
<ul class="simple">
<li><p>Game Logic (bge.logic)</p></li>
<li><p>Game Types (bge.types)</p></li>
<li><p>Rasterizer (bge.render)</p></li>
<li><p>Game Keys (bge.events)</p></li>
<li><p>Video Texture (bge.texture)</p></li>
<li><p>Physics Constraints (bge.constraints)</p></li>
<li><p>Application Data (bge.app)  //TODO</p></li>
</ul>
<p><strong>Stand-Alone Modules</strong></p>
<ul class="simple">
<li><p>Audio System (aud)</p></li>
<li><p>Math Types and Utilities (mathutils)</p></li>
<li><p>OpenGL Wrapper (bgl)</p></li>
<li><p>Font Drawing (blf)</p></li>
</ul>
<section id="bge-logic">
<h3>bge.logic<a class="headerlink" href="#bge-logic" title="Link to this heading"></a></h3>
<p>The main module is a mix of utility functions, global game settings, and logic bricks replacements. Some of those functions were already covered in the tutorial, but they are here again for convenience sake. We will look at some of the highlights.</p>
</section>
<section id="getcurrentcontroller">
<h3>getCurrentController()<a class="headerlink" href="#getcurrentcontroller" title="Link to this heading"></a></h3>
<p>Returns the current controller. This is used to get a list of sensors and actuators (to check status and deactivate respectively), and the object the controller belongs to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">controller</span>  <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">getCurrentController</span><span class="p">()</span>
<span class="nb">object</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">owner</span>
<span class="n">sensor</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">sensors</span><span class="p">[</span><span class="s1">&#39;mysensor&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>If you are using Python modules instead of Python scripts directly (see Python Controller), the controller is passed as an argument for the function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">moduleFunction</span><span class="p">(</span><span class="n">cont</span><span class="p">):</span>
   <span class="nb">object</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">owner</span>
   <span class="n">sensor</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">sensors</span><span class="p">[</span><span class="s1">&#39;mysensor&#39;</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="getcurrentscene">
<h3>getCurrentScene()<a class="headerlink" href="#getcurrentscene" title="Link to this heading"></a></h3>
<p>This function returns the current scene the script was called from. The most common usage is to give you a list of all the game objects:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nb">object</span> <span class="ow">in</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">getCurrentScene</span><span class="p">()</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="expandpath">
<h3>expandPath()<a class="headerlink" href="#expandpath" title="Link to this heading"></a></h3>
<p>If you need to access an external file (image, video, Blender, etc.), you need to first get its absolute path in the computer. Use single backslash (/) to separate folders and double backslash (//) if you need to refer to the current folder:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">video_absolute_path</span>  <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">expandPath</span><span class="p">(</span><span class="s1">&#39;//videos/video01.ogg&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="sendmessage-addscene-start-restart-endgame">
<h3>sendMessage(), addScene(), start/restart/endGame()<a class="headerlink" href="#sendmessage-addscene-start-restart-endgame" title="Link to this heading"></a></h3>
<p>These functions copy the functionality of existent actuators. They are Python replacement for those global events when you need a direct way to call them, bypassing the logic bricks.</p>
</section>
</section>
<section id="libload-libnew-libfree-liblist-todo-to-be-replaced-with-new-ones">
<h2>LibLoad(), LibNew(), LibFree(), LibList() (TODO to be replaced with new ones)<a class="headerlink" href="#libload-libnew-libfree-liblist-todo-to-be-replaced-with-new-ones" title="Link to this heading"></a></h2>
<p>There are cases when you need to load the content of an external Blender file at runtime. This is known as _dynamic loading._ The game engine supports dynamic loading of actions, meshes, or complete scenes. The new data blocks are merged into the current scene and behave just like internal objects:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">LibLoad</span><span class="p">(</span><span class="s2">&quot;//entities.blend&quot;</span><span class="p">,</span> <span class="s2">&quot;Scene&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Beware of Lamps</strong></p>
<p>New Lamp objects can be dynamically loaded from external files. However, in GLSL mode, they will not work as a light source for the material shaders, since the shaders would need to be recompiled for that.</p>
</div>
</section>
<section id="globaldict-loadglobaldict-saveglobaldict">
<h2>globalDict, loadGlobalDict(), saveGlobalDict()<a class="headerlink" href="#globaldict-loadglobaldict-saveglobaldict" title="Link to this heading"></a></h2>
<p>The bge.logic.globalDict is a Python dictionary that is alive during the whole game. It’s a game place to store data if you need to restart the game or load a new file (level) and need to save some properties. In fact, you can even save the globalDict with the Blender file during the game and reload later.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">globalDict</span><span class="p">[</span><span class="s2">&quot;password&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;kidding, kids never save your passwords in files!&quot;</span>
<span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">saveGlobalDict</span><span class="p">()</span> <span class="c1"># save globalDict externally</span>
<span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">loadGlobalDict</span><span class="p">()</span> <span class="c1"># replace the current globalDict with the saved one</span>
</pre></div>
</div>
<section id="keyboard">
<h3>keyboard<a class="headerlink" href="#keyboard" title="Link to this heading"></a></h3>
<p>You can handle all the keyboard inputs directly from a script. The usage and syntax are very similar to the Keyboard sensor. You need a script running every logic tic (Always sensor pulsing with a frequency of 0 or every time a key is pressed; Keyboard sensor with “All Keys” set) where you can read the status of all the keys in the bge.logic.keyboard. events dictionary. If instead of inquiry for the status of a particular key (e.g., if spacebar is pressed), you want to list all the pressed keys, you can use the dictionary bge.logic.keyboard.active_events.</p>
<p>The keys for both event dictionaries are the same you use with the Keyboard sensor (see the bge.events module). The status of each key (whether it was pressed, released, kept pressed, or nothing) is the value stored in the dictionary. The keys values are defined in the bge.logic module itself:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">keyboard</span> <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">keyboard</span>
<span class="n">space_status</span> <span class="o">=</span> <span class="n">keyboard</span><span class="o">.</span><span class="n">events</span> <span class="p">[</span><span class="n">bge</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">SPACEKEY</span><span class="p">]</span>
<span class="k">if</span> <span class="n">space_status</span> <span class="o">==</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">KX_INPUT_JUST_ACTIVATED</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;space key was just pressed.&quot;</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">space_status</span> <span class="o">==</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">KX_INPUT_ACTIVE</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;space key is still pressed.&quot;</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">space_status</span> <span class="o">==</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">KX_INPUT_JUST_RELEASED</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;space key was just released.&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span> <span class="c1"># bge.logic.KX_INPUT_NONE</span>
   <span class="k">pass</span>
</pre></div>
</div>
<p>A sample file can be seen at BookChapter75_game_keyskey_detector_python.blend . This shows the more Python-centric way of handling keyboard. For the classic method of using a Keyboard sensor, look further in this chapter into the “bge.events” section.</p>
</section>
<section id="mouse">
<h3>mouse<a class="headerlink" href="#mouse" title="Link to this heading"></a></h3>
<p>Similar to the keyboard, this Python object can work as a replacement for the Mouse sensor. There are a few differences that make it even more appealing for scripting[md]in particular, the fact that the mouse coordinates are already normalized. As we explained in the tutorial, this helps you get consistent results, regardless of the desktop resolution. The available attributes are:</p>
<ul class="simple">
<li><p><strong>events</strong> - a dictionary with all the events of the mouse (left-click, wheel up, and so on) and their status (for example, bge.logic.KX_INPUT_JUST_ACTIVED).</p></li>
<li><p><strong>position</strong> - normalized position of the mouse cursor in the screen (from [0,0] to [1,1]).</p></li>
<li><p><strong>visible</strong> - show/hide the mouse cursor (can also be set in the Render panel for the initial state).</p></li>
</ul>
</section>
<section id="joysticks">
<h3>joysticks<a class="headerlink" href="#joysticks" title="Link to this heading"></a></h3>
<p>This is a list of all the joysticks your computer supports. That means the list is mainly populated by None objects, and a few, if any, joystick Python objects. To print the index, name, number of axis, and active buttons of the connected joysticks, you can do:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">joysticks</span><span class="p">:</span>
   <span class="n">joystick</span> <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">joysticks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
   <span class="k">if</span> <span class="n">joystick</span> <span class="ow">and</span> <span class="n">joystick</span><span class="o">.</span><span class="n">connected</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">joystick</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">joystick</span><span class="o">.</span><span class="n">numAxis</span><span class="p">,</span> <span class="n">joystick</span><span class="o">.</span><span class="n">activeButtons</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="others">
<h3>Others<a class="headerlink" href="#others" title="Link to this heading"></a></h3>
<p>There are even more functions available in this module (setMist, getLogicTicRate, and setGravity, for example). Make sure that you visit the online documentation (or the documentation included on the book files) to see them all.</p>
</section>
</section>
<section id="bge-types">
<h2>bge.types<a class="headerlink" href="#bge-types" title="Link to this heading"></a></h2>
<p>Objects, meshes, logic bricks, and even shaders are all different game types. Every time you call an internal function from one of them, you are accessing one of those functions. This happens when you get a position of an object, change an actuator value, and so on.</p>
<p>Each one of the classes has the same anatomy. You can access instance methods and instance variables. In order to explain their use properly, we will go over one of the most commonly used modules, the game object.</p>
<p>Some of the variables will only work inside the correct context. Therefore, you can’t get the mouse position of a Mouse sensor if the sensor was not triggered yet. Be aware of the right context and the game type.</p>
</section>
<section id="class-kx-gameobject">
<h2>Class KX_GameObject<a class="headerlink" href="#class-kx-gameobject" title="Link to this heading"></a></h2>
<p>If you run a print(dir (object)) inside your script, you will get a very confusing list. It includes Python internal methods, instance methods, and instance variables. Most of them are common to all objects, so we are going to talk about them first. However, lamps and cameras not only inherit all the game object methods but also extend them with specific ones.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>The Truth Is Out There</strong></p>
<p>In order to see all available methods, please refer to the documentation. We are only covering a few of them here.</p>
</div>
<section id="python-internal-methods">
<h3>Python Internal Methods<a class="headerlink" href="#python-internal-methods" title="Link to this heading"></a></h3>
<p><cite>__class__, __doc__, __delattr__ …</cite></p>
<p>Most of those methods are inherited from the Python object we are dealing with. However, given the nature of the Python classes presented in Blender, some of those methods may not be fully accessible. It’s unlikely you will be using them. So for now it’s safe to ignore any method starting and ending with double underlines (__ignoreme__).</p>
</section>
<section id="instance-methods">
<h3>Instance Methods<a class="headerlink" href="#instance-methods" title="Link to this heading"></a></h3>
<p><cite>endObject(), rayCast(), getAxisVect(), suspendDynamics(), getPropertyNames() …</cite></p>
<p>If it looks like a function, it should be one. Every game engine object provides you with a set of functions to interact with them or from them to the others. Here are some methods you should know about:</p>
<ul class="simple">
<li><p><strong>rayCast (objto, objfrom, dist, prop, face, xray, poly)</strong></p></li>
</ul>
<p><em>“Look from a point/object to another point/object and find first object hit within dist that matches prop.”</em></p>
<p>This method is a more complete version of the rayCastTo(). It has so many applications that it becomes hard to delimitate its usage. For instance, this was the method used to calculate the collision in the navigation system script we studied previously.</p>
<ul class="simple">
<li><p><strong>getPropertyNames()</strong></p></li>
</ul>
<p><em>“Get a list of all property names.”</em></p>
<p>Once you retrieve the list of property names, you can use it to see if the object has a specific property before using it. To get individual properties, you can use <em>if “prop” in object</em>: or <em>object.get(“prop”, default=None)</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>A Use for Properties</strong></p>
<p>Properties have multiple uses in the game engine. One of those uses is to mark an object to be identified by the Python script. Why not use their names instead? While names work fine to retrieve individual objects, properties allow you to easily mark and access multiple objects at once. Frankly, it’s easier to create an organized, named, and tagged MP3 collection than it is to find time to properly name all your Blender data blocks[ms]objects, meshes, materials, textures, images, and so on.</p>
</div>
<ul class="simple">
<li><p><strong>endObject()</strong></p></li>
</ul>
<p><em>“Delete this object can be used in place of the EndObject Actuator.”</em></p>
<p>This method is one of the functions that mimic existent actuators. You will also find this design in methods such as sendMessage(), setParent(), and replaceMesh().</p>
<ul class="simple">
<li><p><strong>applyRotation()</strong></p></li>
</ul>
<p><em>“Set the game object’s movement/rotation.”</em></p>
<p>There are a few methods that will free you from doing 3D math manually. This particular one is a replacement for multiplying the object orientation matrix by a rotation matrix. (If you are “old school,” you can still set the orientation matrix directly though.)</p>
<p>Other methods are applyMovement(), applyForce(), applyTorque(), getDistanceTo(), getVectTo(), getAxisVect(), and alignAxisToVect().</p>
</section>
<section id="instance-variables">
<h3>Instance Variables<a class="headerlink" href="#instance-variables" title="Link to this heading"></a></h3>
<p><cite>_name, position, mass, sensors, actuators …_</cite></p>
<p>Last but definitively not least, we have the built-in variables. They work as internal parameters of the object (for example, name, position, orientation) or class objects linked to it (for example, parent, sensors, actuators). In Blender versions prior to 2.49, those variables were only accessible through a conjunct of get and set statements (setPosition(), getOrientation(), and so on). In Blender 2.5, 2.6 and on, they not only can be accessed directly, but also manipulated as any other variable, list, dictionary, vector, or matrix you may have:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">obj</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">obj</span><span class="o">.</span><span class="n">worldScale</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="n">obj</span><span class="o">.</span><span class="n">localPosition</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">3.0</span>
<span class="n">obj</span><span class="o">.</span><span class="n">worldOrientation</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">worldTransform</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>position, localPosition, worldPosition</strong></p></li>
</ul>
<p>Position is a vector [x, y, z] with the location of the object in the scene. We can get the absolute position (worldPosition) or the position relative to the parent of the object (localPosition). And what about accessing the position variable directly? This is deprecated, but you may run into it in old files you find online. If you access the position variable directly, you get the world position on reading and set the local position on writing. Confusing? That is why this is deprecated ;)</p>
<ul class="simple">
<li><p><strong>orientation, localOrientation, worldOrientation</strong></p></li>
</ul>
<p>This variable gives you access to a matrix 3x3 with the orientation of the object. The orientation matrix is the result of the rotation transformation of an object and the influence of its parent object. As with position, the orientation variable will give you the world orientation on reading and set the local orientation on writing. As with position, you should always specify whether you want the local or world orientation.</p>
<ul class="simple">
<li><p><strong>visible</strong></p></li>
</ul>
<p>We have different ways to set the visibility of an object. If your material is not set to invisible in the game panel, you can use this method. To change the visibility recursively (to the children of the object), you must use the method setVisibility.</p>
<ul class="simple">
<li><p><strong>sensors, controllers, actuators</strong></p></li>
</ul>
<p>All the logic bricks of an object can be accessed through those dictionaries. The name of the sensor/controller/actuator will be used as the dictionary key, for it’s important to name them correctly.</p>
</section>
<section id="sub-class-kx-camera">
<h3>Sub-Class KX_Camera<a class="headerlink" href="#sub-class-kx-camera" title="Link to this heading"></a></h3>
<p>Not all the objects have access to the same methods and variables. For example, an empty object doesn’t have mass, and a static object doesn’t have torque.</p>
<p>When the object is a camera, the difference is even more distinct. The camera object has its own class derived from KX_GameObject. It inherits all the instance variables and methods and expands it with its own. You will find some screen space functions (getScreenPosition(),getScreenVect(), getScreenRay()), some frustum methods (sphereInsideFrustum(), boxInsideFrustum(), pointInsideFrustum()), and some instance variables (lens, near, far, frustum_culling, world_to_camera, camera_to_world).</p>
</section>
<section id="sub-class-kx-lamp">
<h3>Sub-Class KX_Lamp<a class="headerlink" href="#sub-class-kx-lamp" title="Link to this heading"></a></h3>
<p>Like cameras, lamps also have their own subclass. It inherits all the instance variables and methods, and only expands the available variables.</p>
<p>The parameters that can be changed with Python include all that can be animated with the Action actuator: energy, color, distance, attenuation, spot size, and spot blend. Additionally, you can change the lamp layer in runtime.</p>
</section>
</section>
<section id="bge-render">
<h2>bge.render<a class="headerlink" href="#bge-render" title="Link to this heading"></a></h2>
<p>If we compare gaming with traditional 3D artwork, rasterizer would be the rendering phase of the process. Internally, it’s when all the geometry is finally drawn to the screen with the light calculation, the filters applied, and the canvas set. For this reason, the Rasterizer module presents functions related to stereoscopy, windows and mouse management, world settings, and global GLSL material settings.</p>
</section>
<section id="window-and-mouse">
<h2>Window and Mouse<a class="headerlink" href="#window-and-mouse" title="Link to this heading"></a></h2>
<p><cite>getWindowWidth() / getWindowHeight()</cite></p>
<p>Get the width/height of the window (in pixels).</p>
<p><cite>showMouse(visible)</cite></p>
<p>Enable or disable the operating system mouse cursor.</p>
<p><cite>setMousePosition(x, y)</cite></p>
<p>Set the mouse cursor position (in pixels).</p>
</section>
<section id="world-settings-todo-to-be-removed-changed">
<h2>World Settings (TODO to be removed/changed)<a class="headerlink" href="#world-settings-todo-to-be-removed-changed" title="Link to this heading"></a></h2>
<p><cite>setBackgroundColor(rgba), setAmbientColor(rgb)</cite></p>
<p>Set the ambient and background color.</p>
<p><cite>setMistColor(rgb), disableMist(), setMistStart(start), setMistEnd(end)</cite></p>
<p>Configure the mist (fog) settings.</p>
</section>
<section id="stereo-settings-todo-to-be-changed">
<h2>Stereo Settings (TODO to be changed)<a class="headerlink" href="#stereo-settings-todo-to-be-changed" title="Link to this heading"></a></h2>
<p><cite>getEyeSeparation() / setEyeSeparation(eyesep)</cite></p>
<p>Get the current eye separation for stereo mode. Usually focal length/30 provides a comfortable value.</p>
<p><cite>getFocalLength() / setFocalLength(focallength)</cite></p>
<p>Get the current focal length for stereo mode. It uses the current camera focal length as initial value</p>
</section>
<section id="material-settings-todo-to-be-changed">
<h2>Material Settings (TODO to be changed)<a class="headerlink" href="#material-settings-todo-to-be-changed" title="Link to this heading"></a></h2>
<p><cite>getMaterialMode(mode) / setMaterialMode(mode)</cite></p>
<p>Get/set the material mode to use for OpenGL rendering. The available modes are:</p>
<p><cite>KX_TEXFACE_MATERIAL, KX_BLENDER_MULTITEX_MATERIAL, KX_BLENDER_GLSL_MATERIAL</cite></p>
<p><cite>getGLSLMaterialSetting(setting) / setGLSLMaterialSetting(setting, enable)</cite></p>
<p>Get/set the state of a GLSL material setting. The available settings are:</p>
<p><cite>“lights”, “shaders”, “shadows”, “ramps”, “nodes”, “extra_textures”</cite></p>
</section>
<section id="id1">
<h2>Others<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<p><cite>drawLine(fromVec, toVec, color)</cite></p>
<p>Draw a line in the 3D scene.</p>
<p><cite>enableMotionBlur(factor) / disableMotionBlur()</cite></p>
<p>Enable/disable the motion blue effect.</p>
<p><cite>makeScreenshot(filename)</cite></p>
<p>Write a screenshot to the given filename.</p>
</section>
<section id="bge-events">
<h2>bge.events<a class="headerlink" href="#bge-events" title="Link to this heading"></a></h2>
<p>The Keyboard sensor allows you to set individual keys. As you can see in Figure 7.15, it can also be triggered by any key once you enable the option “All Keys.” This is very useful to configure text input in your game or to centralize all keyboard events with a single sensor and script.</p>
<p>![Key codes visualizer](../figures/Chapter7/Fig07-15.png)</p>
<p>In this case, every key pressed into a Keyboard sensor, will be registered as a unique integer. Each number corresponds to a specific key, and finding them allows you to control your actions accordingly to the desired key map. In order to clarify this a bit more, try the file in /Book/Chapter7/5_game_keyskey_detector_logicbrick.blend.</p>
<p>This file is similar to the key_detector_python.blend we used to demonstrate bge.logic.keyboard. However, this file is using the Keyboard sensor directly, instead of its wrapper.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bge</span> <span class="kn">import</span> <span class="n">logic</span>
<span class="kn">from</span> <span class="nn">bge</span> <span class="kn">import</span> <span class="n">events</span>
<span class="n">cont</span> <span class="o">=</span> <span class="n">logic</span><span class="o">.</span><span class="n">getCurrentController</span><span class="p">()</span>
<span class="n">owner</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">owner</span>
<span class="n">sensor</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">sensors</span><span class="p">[</span><span class="s2">&quot;s_keyboard&quot;</span><span class="p">]</span>

<span class="k">if</span> <span class="n">sensor</span><span class="o">.</span><span class="n">positive</span><span class="p">:</span>
   <span class="c1"># get the first pressed key</span>
   <span class="n">pressed_key</span> <span class="o">=</span> <span class="n">sensor</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
   <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;the key number is: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">pressed_key</span>
   <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;the key value is: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">events</span><span class="o">.</span><span class="n">EventToString</span><span class="p">(</span><span class="n">pressed_key</span><span class="p">)</span>
   <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;the character is: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">events</span><span class="o">.</span><span class="n">EventToCharacter</span><span class="p">(</span><span class="n">pressed_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

   <span class="c1"># press space to reset the initial text</span>
   <span class="k">if</span> <span class="n">pressed_key</span> <span class="o">==</span> <span class="n">events</span><span class="o">.</span><span class="n">SPACEKEY</span><span class="p">:</span>
      <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Please, press any key.&quot;</span>
   <span class="n">owner</span><span class="p">[</span><span class="s2">&quot;Text&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">text</span>
</pre></div>
</div>
<p>This script is called every time someone presses a key. The key (or keys) are registers as a list of events, each one being a list with the pressed key and its status. In this case, we are reading only the first pressed key:</p>
<p><cite>pressed_key = sensor.events[0][0]</cite></p>
<p>This line stores the integer that identifies the pressed key. However, we usually would need to know the actual pressed key, not its internal integer value. Therefore, we are using the only two functions available in this module to convert our key to an understandable value:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;the key value is: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">events</span><span class="o">.</span><span class="n">EventToString</span><span class="p">(</span><span class="n">pressed_key</span><span class="p">)</span>
<span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;the character is: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">events</span><span class="o">.</span><span class="n">EventToCharacter</span><span class="p">(</span><span class="n">pressed_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>After that, we are checking for a specific key (spacebar). bge.events.SPACEKEY is actually an integer (to find the other keys’ names, visit the API page):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">pressed_key</span> <span class="o">==</span> <span class="n">events</span><span class="o">.</span><span class="n">SPACEKEY</span><span class="p">:</span> <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Please, press any key.&quot;</span>
</pre></div>
</div>
<p>And, voilà, now we only need to visualize the pressed key:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">owner</span><span class="p">[</span><span class="s2">&quot;Text&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">text</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Key Status</strong></p>
<p>The status of a key is what informs you whether the key has just been pressed or if it was pressed already. The Keyboard sensor is always positive as long as any key is held, and you may need to trigger different functions when some keys are pressed and released. The status values are actually stored in bge.logic:</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">KX_INPUT_NONE</span>
<span class="mi">1</span> <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">KX_INPUT_JUST_ACTIVATED</span>
<span class="mi">2</span> <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">KX_INPUT_ACTIVE</span>
<span class="mi">3</span> <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">KX_INPUT_JUST_RELEASED</span>
</pre></div>
</div>
</section>
<section id="bge-texture">
<h2>bge.texture<a class="headerlink" href="#bge-texture" title="Link to this heading"></a></h2>
<p>The texture module was first discussed in the Chapter 5, “Graphics.” With the texture module, you can change any texture from your game while the game is running. The texture can be replaced by a single image, a video, a game camera, and even a webcam stream.</p>
<p>Let’s look at a basic example. Please open the file: BookChapter76_texturebasic_texture_replacement.blend.</p>
<p>This file has a single plane with a texture we will replace with an external image. Press the spacebar to change the image and Enter to return to the original one. The script responsible for the texture switching is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bge</span> <span class="kn">import</span> <span class="n">logic</span>
<span class="kn">from</span> <span class="nn">bge</span> <span class="kn">import</span> <span class="n">texture</span>
<span class="k">def</span> <span class="nf">createTexture</span><span class="p">(</span><span class="n">cont</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Create a new dynamic texture&quot;&quot;&quot;</span>
   <span class="nb">object</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">owner</span>

   <span class="c1"># get the reference pointer (ID) of the texture</span>
   <span class="n">ID</span> <span class="o">=</span> <span class="n">texture</span><span class="o">.</span><span class="n">materialID</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;IMoriginal.png&#39;</span><span class="p">)</span>

   <span class="c1"># create a texture object</span>
   <span class="n">dynamic_texture</span> <span class="o">=</span> <span class="n">texture</span><span class="o">.</span><span class="n">Texture</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">ID</span><span class="p">)</span>

   <span class="c1"># create a new source</span>
   <span class="n">url</span> <span class="o">=</span> <span class="n">logic</span><span class="o">.</span><span class="n">expandPath</span><span class="p">(</span><span class="s2">&quot;//media/newtexture.jpg&quot;</span><span class="p">)</span>
   <span class="n">new_source</span> <span class="o">=</span> <span class="n">texture</span><span class="o">.</span><span class="n">ImageFFmpeg</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

   <span class="c1"># the texture has to be stored in a permanent Python object</span>
   <span class="n">logic</span><span class="o">.</span><span class="n">dynamic_texture</span> <span class="o">=</span> <span class="n">dynamic_texture</span>

   <span class="c1"># update/replace the texture</span>
   <span class="n">dynamic_texture</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">new_source</span>
   <span class="n">dynamic_texture</span><span class="o">.</span><span class="n">refresh</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">removeTexture</span><span class="p">(</span><span class="n">cont</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Delete the dynamic texture, reversing it back to the original one.&quot;&quot;&quot;</span>
   <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="n">logic</span><span class="o">.</span><span class="n">dynamic_texture</span>
   <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
</pre></div>
</div>
<p>It’s a simple script, but let’s look at the individual steps. We start by getting the material ID (that can be retrieved for an image used by an object, hence the prefix IM) or a material that uses a texture (with the prefix MA).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ID</span> <span class="o">=</span> <span class="n">texture</span><span class="o">.</span><span class="n">materialID</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;IMoriginal.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>With this ID, we can create a Texture object that controls the texture to be used by this object (and the other objects sharing the same image/material).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dynamic_texture</span> <span class="o">=</span> <span class="n">texture</span><span class="o">.</span><span class="n">Texture</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">ID</span><span class="p">)</span>
</pre></div>
</div>
<p>The next step is to create the source to replace the texture with. The bge.texture module supports the following sources: ImageFFmpeg (images), VideoFFmpeg (videos), ImageBuff (data buffer), ImageMirror (mirror), ImageRender (game camera), ImageViewport (current viewport), and ImageMix (a mix of sources).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_source</span> <span class="o">=</span> <span class="n">texture</span><span class="o">.</span><span class="n">ImageFFmpeg</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we only need to assign the new source to be used by the object texture and to refresh the latter. The refresh function has a Boolean argument for advanced settings. A rule of thumb is: for videos, use refresh (True); for everything else, try refresh (False) first.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dynamic_texture</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">new_source</span>
<span class="n">dynamic_texture</span><span class="o">.</span><span class="n">refresh</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>For the image to be permanent, we have to make sure the new dynamic_texture is not destructed after we leave our Python function. Therefore, we store it in the global module bge.logic. If you need to reset the texture to its original source, simply delete the stored object (for example, <em>del logic.dynamic_texture</em>).</p>
<p>Since this is a simple image, you don’t need to do anything after that. If you are using a video as source, you need to keep refreshing the texture every frame. Videos also support an audio-video syncing system. To make them play harmoniously together, you first play the audio and then query its current position to pass as a parameter when updating the video frame (for example,  _logic.video.refresh(True, logic.sound.time)_). The audio can come from an Audaspace object or even a Sound actuator.</p>
<p>In the book files, you can find other examples using different sorts of source objects:</p>
<p>Basic replacement of texture:</p>
<p>/Book/Chapter7/6_texture/basic_texture_replacement.blend</p>
<p>Basic video playback with Sound actuator:</p>
<p>/Book/Chapter7/6_texture/basic_video_sound.blend</p>
<p>Video player with interface controllers:</p>
<p>/Book/Chapter7/6_texture/player_video_audio.blend</p>
<p>Basic video playback with Audaspace:</p>
<p>/Book/Chapter7/6_texture/video_audaspace.blend</p>
<p>Mirror effect:</p>
<p>/Book/Chapter7/6_texture/mirror.blend</p>
<p>Render to texture:</p>
<p>/Book/Chapter7/6_texture/render_to_texture.blend</p>
<p>Webcam sample:</p>
<p>/Book/Chapter7/6_texture/webcam.blend</p>
</section>
<section id="bge-constraints">
<h2>bge.constraints<a class="headerlink" href="#bge-constraints" title="Link to this heading"></a></h2>
<p>The Bullet Physics engine allows for advanced control over the physics simulation in your game. Using Bullet as a backend, this module (formerly known as <em>Physics Constraints</em>) allows you to create and set up rigid joints, dynamic constraints, and even a vehicle wrapper. The constraints’ functionalities make sense only when you understand the context in which they are to be used (with physic dynamic objects). Therefore, this module is covered in the previous chapter on game physics.</p>
</section>
<section id="mathutils-math-types-and-utilities">
<h2>Mathutils - Math Types and Utilities<a class="headerlink" href="#mathutils-math-types-and-utilities" title="Link to this heading"></a></h2>
<p>Mathutils is a generic module common to both Blender and the game engine. There are a lot of methods to facilitate your script in handling 3D math operations. You won’t have to reinvent the wheel every time you need to multiply vectors or transpose matrixes. Simply using the mathutils classes and built-in methods frees you to invest your time in something far more important: relearning all of the long-forgotten math lessons you skipped.</p>
<p>Unless your background is in math, physics, or engineering, you won’t use this module any time soon. For those already familiar with the passionate secrets of math, you’ll be glad to know that those module’s functions are mainly self-explanatory. Names such as cross, dot, slerp (what?), and a quick look at their specifications will be all you need to know to start working with them. Nevertheless, newcomers often use this module without even knowing it. Every time you change an object position, get the vector from an object, or apply a rotation, you are using mathutils classes and methods. Therefore, it’s good to have this module as a reference for further studies and more advanced coding. (We all get there eventually.)</p>
<p>We are going to present the four available classes in this module: vector, matrix, Euler, and quaternion. For a list of the available methods, refer to the API documentation.</p>
</section>
<section id="vector">
<h2>Vector<a class="headerlink" href="#vector" title="Link to this heading"></a></h2>
<p>This class was already present in the KX_GameObject class and in the script example. It behaves like a list object, with some advanced features (for example, swizzle and slicing) expanded with its instance methods. Some of those methods are: reflect, dot, cross, and normalize.</p>
<p>A recurring problem that new Python programmers have is with list copying. If you forget to manually copy the list when assigning it to a new variable, you end up with two variables sharing the same list values forever (each of the variables becomes a pointer to the same data).</p>
<p>The same behavior happens with Vectors. Look at the differences:</p>
<p><cite>new_vector = old_vector</cite></p>
<p>if you change new_vector you will automatically change old_vector (and vice-versa).</p>
<p><cite>new_vector = old_vector[:]</cite></p>
<p>new_vector is a new independent list object initialized with the old_vector values.</p>
<p><cite>new_vector = vector.copy()</cite></p>
<p>new_vector is a new Vector, an independent copy of the old_vector object.</p>
</section>
<section id="matrix">
<h2>Matrix<a class="headerlink" href="#matrix" title="Link to this heading"></a></h2>
<p>While vectors behave similarly to lists, matrices behave similarly to multidimensional lists. A multidimensional list is a list of a list, organized either in columns or rows.</p>
<p>While in Python, a list of a list is always the same:</p>
<p><cite>matrix_row = [[1,2,3], [4,5,6], [7,8,9]]</cite></p>
<p>In a mathutils.Matrix, the data can be stored differently, accordingly to the matrix orientation (row/column). Following you can see how the order of the elements in a matrix changes, according to its orientation (note, this is not actual Python code):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">matrix_row_major</span>    <span class="o">=</span>  <span class="p">[[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
                       <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span>
                       <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">]</span> <span class="p">]</span>

                      <span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">7</span><span class="p">]</span>
<span class="n">matrix_column_major</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span><span class="mi">2</span><span class="o">||</span><span class="mi">5</span><span class="o">||</span><span class="mi">8</span><span class="o">|</span><span class="p">]</span>
                      <span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">6</span><span class="p">][</span><span class="mi">9</span><span class="p">]</span>
</pre></div>
</div>
<p>It’s important to be aware of the ordering of your matrices; otherwise, you end up using a transposed matrix for your calculations. Since all the game engine internal matrices (orientation, camera to world, and so on) are column-major oriented, you will be safer sticking to this standard.</p>
<p>If your matrix represents a transformation matrix (rotation, translation, and scale) you can get its values separately. Matrix.to_quaternion() and Matrix.to_euler() will give you the rotation part of the matrix in the form you prefer (see next section), and Matrix.to_translation() and Matrix.to_scale () will give you the translation and the scale vector, respectively.</p>
</section>
<section id="euler-and-quaternion">
<h2>Euler and Quaternion<a class="headerlink" href="#euler-and-quaternion" title="Link to this heading"></a></h2>
<p>Euler and quaternion are different rotation systems. The same rotation can be represented using Euler, quaternion, or an orientation matrix.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Guerrilla CG</strong></p>
<p>You can find two great video tutorials on the Guerrilla CG vimeo channel that explain and compare the two rotation system:</p>
<p>Euler Rotations Explained: <a class="reference external" href="http://vimeo.com/2824431">http://vimeo.com/2824431</a></p>
<p>The Rotation Problem: <a class="reference external" href="http://vimeo.com/2649637">http://vimeo.com/2649637</a></p>
<p>When you convert an orientation matrix to Euler (<cite>Matrix.to_euler()</cite>), you get a list with three angles. They represent the rotation in the x, y, z axis of the object. In the navigation system script example, we are using this exact method to determine the horizontal camera angle. You can find this usage in the function <cite>fly_to_walk()</cite> (lines 190 to 199 of navigation_system.py or in the early pages of this chapter).</p>
<p>Conversion Between Different Rotation Forms</p>
<p>You can convert an orientation matrix to Euler, an Euler to a quaternion, a quaternion to an orientation matrix, and on and on and on:</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">original_matrix</span><span class="o">=</span><span class="n">mathutils</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">Rotation</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">)</span>

<span class="n">converted_matrix</span><span class="o">=</span><span class="n">original_matrix</span><span class="o">.</span><span class="n">to_euler</span><span class="p">()</span><span class="o">.</span><span class="n">to_quaternion</span><span class="p">()</span><span class="o">.</span><span class="n">to_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">to_euler</span><span class="p">()</span><span class="o">.</span><span class="n">to_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">to_quaternion</span><span class="p">()</span><span class="o">.</span><span class="n">to_euler</span><span class="p">()</span><span class="o">.</span><span class="n">to_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">to_quaternion</span><span class="p">()</span><span class="o">.</span><span class="n">to_euler</span><span class="p">()</span><span class="o">.</span><span class="n">to_quaternion</span><span class="p">()</span><span class="o">.</span><span class="n">to_matrix</span><span class="p">()</span>
</pre></div>
</div>
<p>In this example, converted_matrix ends up as the same matrix as original_matrix.</p>
</section>
<section id="aud-audio-system">
<h2>aud - Audio System<a class="headerlink" href="#aud-audio-system" title="Link to this heading"></a></h2>
<p>This module allows you to play sounds directly from your scripts. There are three classes you will be working with: Device, Factory, and Handle.</p>
<p>The audaspace module in a nutshell: you need to create one audio Device per game. You need one Factory per audio file (which can also be any video file containing a sound track). And every time you need to play a sound, a new Handle object will be generated from the Factory (this is where its name comes from).</p>
</section>
<section id="example-basic-audio-playback-todo-to-be-adapted-to-new-api">
<h2>Example: Basic Audio Playback (TODO to be adapted to new API)<a class="headerlink" href="#example-basic-audio-playback-todo-to-be-adapted-to-new-api" title="Link to this heading"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">aud</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">aud</span><span class="o">.</span><span class="n">Device</span><span class="p">()</span>
</pre></div>
</div>
<p>## load sound file (it can be a video file with audio)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sound</span> <span class="o">=</span> <span class="n">aud</span><span class="o">.</span><span class="n">Sound</span><span class="p">(</span><span class="s1">&#39;music.ogg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>## play the audio, this return a handle to control play/pause</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">handle</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">play</span><span class="p">(</span><span class="n">sound</span><span class="p">)</span>
</pre></div>
</div>
<p>## if the audio is not too big and will be used often you can buffer it</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sound_buffered</span> <span class="o">=</span> <span class="n">aud</span><span class="o">.</span><span class="n">Sound</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">sound</span><span class="p">)</span>
<span class="n">handle_buffered</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">play</span><span class="p">(</span><span class="n">sound_buffered</span><span class="p">)</span>
</pre></div>
</div>
<p>## stop the sounds (otherwise they play until their ends)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">handle</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
<span class="n">handle_buffered</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p>We start by creating an audio device. This is simply a Python object you will use to play your sounds. Next, we create a Factory object. A factory is a container for a sound file. When we pass the Factory object into the device play function, it will start playing the sound and return a handle. Handles are used to control pause/resume and to stop an audio.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>When Will This Music Stop?</strong></p>
<p>After you initialize a sound, you can get its current position in seconds with the handle.position Python property. This is especially useful to keep videos and audio in sync. If you need to check whether or not the audio is ended, you shouldn’t rely on the position, though. Instead, you can get the status of the sound by the property handle.status. If you are using the sound position to control a video playback, the sound status will also tell you if the video is over (handle.status = aud.AUD_STATUS_INVALID). The possible statuses are:</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="n">aud</span><span class="o">.</span><span class="n">AUD_STATUS_INVALID</span>
<span class="mi">1</span> <span class="o">=</span> <span class="n">aud</span><span class="o">.</span><span class="n">AUD_STATUS_PLAYING</span>
<span class="mi">2</span> <span class="o">=</span> <span class="n">aud</span><span class="o">.</span><span class="n">AUD_STATUS_PAUSED</span>
</pre></div>
</div>
</section>
<section id="bgl-opengl-wrapper">
<h2>bgl - OpenGL Wrapper<a class="headerlink" href="#bgl-opengl-wrapper" title="Link to this heading"></a></h2>
<p>This module is a wrapping of OpenGL constants and functions. It allows you to access low-level graphic resources within the game engine. You can use this module to draw directly to the screen or to read OpenGL matrices and buffers directly.</p>
<p>Sometimes, you will need to run your OpenGL code specifically before or after the game engine drawing routine, so you can store your Python function as a list element either in the scene attributes pre_draw and/or in the post_draw. This will be demonstrated in our first example.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>To Learn OpenGL</strong></p>
<p>You can find good OpenGL learning material on the Internet or in a bookstore. <em>The Official Guide to Learning OpenGL</em> (also known as <em>The Red Book</em>) is highly recommended, and some older versions of it can be found online for download.</p>
</div>
<section id="example-01-line-width-changing">
<h3>Example 01: Line Width Changing<a class="headerlink" href="#example-01-line-width-changing" title="Link to this heading"></a></h3>
<p>Open the file /Book/Chapter7/7_bgl/line_width.blend.</p>
<p>(run it in wireframe mode)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bge</span> <span class="kn">import</span> <span class="n">logic</span>
<span class="kn">import</span> <span class="nn">bgl</span>
<span class="k">def</span> <span class="nf">line_width</span><span class="p">():</span>
   <span class="n">bgl</span><span class="o">.</span><span class="n">glLineWidth</span><span class="p">(</span><span class="mf">100.0</span><span class="p">)</span>

<span class="n">scene</span> <span class="o">=</span> <span class="n">logic</span><span class="o">.</span><span class="n">getCurrentScene</span><span class="p">()</span>
<span class="k">if</span> <span class="n">line_width</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scene</span><span class="o">.</span><span class="n">pre_draw</span><span class="p">:</span>
   <span class="n">scene</span><span class="o">.</span><span class="n">pre_draw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_width</span><span class="p">)</span>
</pre></div>
</div>
<p>This code needs to run only once per frame and will change the line width of the objects. Be aware that the line is only drawn in the wireframe mode.</p>
<p>You will find on the book files another example where the line width changes dynamically - /Book/Chapter7/7_bgl/line_width_animate.blend.</p>
</section>
<section id="example-02-color-picker">
<h3>Example 02: Color Picker<a class="headerlink" href="#example-02-color-picker" title="Link to this heading"></a></h3>
<p>Open the file /Book/Chapter7/7_bgl/color_pickup.blend.</p>
<p>In this file, you can change the light color according to where you click.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bge</span> <span class="kn">import</span> <span class="n">logic</span>
<span class="kn">from</span> <span class="nn">bge</span> <span class="kn">import</span> <span class="n">render</span>
<span class="kn">import</span> <span class="nn">bgl</span>

<span class="n">cont</span> <span class="o">=</span> <span class="n">logic</span><span class="o">.</span><span class="n">getCurrentController</span><span class="p">()</span>
<span class="n">lamp</span>   <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">owner</span>
<span class="n">sensor</span> <span class="o">=</span> <span class="n">cont</span><span class="o">.</span><span class="n">sensors</span><span class="p">[</span><span class="s2">&quot;s\_mouse\_click&quot;</span><span class="p">]</span>

<span class="k">if</span> <span class="n">sensor</span><span class="o">.</span><span class="n">positive</span><span class="p">:</span>
   <span class="n">width</span> <span class="o">=</span> <span class="n">render</span><span class="o">.</span><span class="n">getWindowWidth</span><span class="p">()</span>
   <span class="n">height</span> <span class="o">=</span> <span class="n">render</span><span class="o">.</span><span class="n">getWindowHeight</span><span class="p">()</span>
   <span class="n">viewport</span> <span class="o">=</span> <span class="n">bgl</span><span class="o">.</span><span class="n">Buffer</span><span class="p">(</span><span class="n">bgl</span><span class="o">.</span><span class="n">GL_INT</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
   <span class="n">bgl</span><span class="o">.</span><span class="n">glGetIntegerv</span><span class="p">(</span><span class="n">bgl</span><span class="o">.</span><span class="n">GL_VIEWPORT</span><span class="p">,</span> <span class="n">viewport</span><span class="p">);</span>
   <span class="n">x</span> <span class="o">=</span> <span class="n">viewport</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sensor</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
   <span class="n">y</span> <span class="o">=</span> <span class="n">viewport</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="n">sensor</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
   <span class="n">pixels</span> <span class="o">=</span> <span class="n">bgl</span><span class="o">.</span><span class="n">Buffer</span><span class="p">(</span><span class="n">bgl</span><span class="o">.</span><span class="n">GL_FLOAT</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">])</span>

   <span class="c1"># Reads one pixel from the screen, using the mouse position</span>
   <span class="n">bgl</span><span class="o">.</span><span class="n">glReadPixels</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bgl</span><span class="o">.</span><span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">bgl</span><span class="o">.</span><span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">pixels</span><span class="p">)</span>

   <span class="c1"># Change the Light colour</span>
   <span class="n">lamp</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="n">pixels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pixels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pixels</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
</pre></div>
</div>
<p>There are three important bgl methods been used here. The first one is bgl.Buffer. It creates space in the memory to be filled in with information taken from the graphics driver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">viewport</span> <span class="o">=</span> <span class="n">bgl</span><span class="o">.</span><span class="n">Buffer</span><span class="p">(</span><span class="n">bgl</span><span class="o">.</span><span class="n">GL_INT</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">pixels</span> <span class="o">=</span> <span class="n">bgl</span><span class="o">.</span><span class="n">Buffer</span><span class="p">(</span><span class="n">bgl</span><span class="o">.</span><span class="n">GL_FLOAT</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
<p>The second one is the <cite>bgl.glGetIntegerv</cite>. We use it to get the current Viewport position and dimension to the buffer object previously created:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">glGetIntegerv</span><span class="p">(</span><span class="n">bgl</span><span class="o">.</span><span class="n">GL_VIEWPORT</span><span class="p">,</span> <span class="n">viewport</span><span class="p">);</span>
</pre></div>
</div>
<p>The buffer coordinates run from the left bottom [0.0, 0.0] to the right top [1.0, 1.0]. The mouse coordinates, on the other hand, run from left top [0, 0] to the right bottom [width, height]. We need to convert the mouse coordinate position to the correspondent one in the Buffer.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">viewport</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sensor</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">viewport</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="n">sensor</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The third one is bgl.glReadPixels. This is the method that’s actually reading the pixel color and storing it in the other buffer object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bgl</span><span class="o">.</span><span class="n">glReadPixels</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bgl</span><span class="o">.</span><span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">bgl</span><span class="o">.</span><span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">pixels</span><span class="p">)</span>
</pre></div>
</div>
<p>And, finally, let’s apply the pixel color to the lamp:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lamp</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="n">pixels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pixels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pixels</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
</pre></div>
</div>
</section>
</section>
<section id="blf-font-drawing">
<h2>blf - Font Drawing<a class="headerlink" href="#blf-font-drawing" title="Link to this heading"></a></h2>
<p>If you need to control text drawing directly from your scripts, you may need to use this module. Be aware, though, that this module is a low-level API that has to be combined with the OpenGL wrapper to handle texts properly.</p>
<p>The blf module works in three stages:</p>
<ol class="arabic simple">
<li><p>Create a new font object.</p></li>
<li><p>Set the parameters for the text (size, position, and so on).</p></li>
<li><p>Draw the text on the screen.</p></li>
</ol>
<section id="example-writing-hello-world">
<h3>Example: Writing Hello World<a class="headerlink" href="#example-writing-hello-world" title="Link to this heading"></a></h3>
<p>Open the file /Book/Chapter7/8_blf/hello_world.blend.</p>
<p>In the init function, we load a new font in memory and store the generated font ID to use later.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">init</span><span class="p">():</span>

<span class="w">   </span><span class="sd">&quot;&quot;&quot;init function - runs once&quot;&quot;&quot;</span>

   <span class="c1"># create a new font object</span>
   <span class="n">font_path</span> <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">expandPath</span><span class="p">(</span><span class="s1">&#39;//fonts/Zeyada.ttf&#39;</span><span class="p">)</span>
   <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">font_id</span> <span class="o">=</span> <span class="n">blf</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">font_path</span><span class="p">)</span>

   <span class="c1"># set the font drawing routine to run</span>
   <span class="n">scene</span> <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">getCurrentScene</span><span class="p">()</span>
   <span class="n">scene</span><span class="o">.</span><span class="n">post_draw</span><span class="o">=</span><span class="p">[</span><span class="n">write</span><span class="p">]</span>
</pre></div>
</div>
<p>The actual function responsible for writing the text is stored in the scene post_draw routine. Apart from the OpenGL calls, the setup for using the text is quite simple.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">write</span><span class="p">():</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;write on screen – runs every frame&quot;&quot;&quot;</span>
   <span class="n">width</span> <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">render</span><span class="o">.</span><span class="n">getWindowWidth</span><span class="p">()</span>
   <span class="n">height</span> <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">render</span><span class="o">.</span><span class="n">getWindowHeight</span><span class="p">()</span>

   <span class="c1"># OpenGL calls to re-set drawing position</span>
   <span class="n">bgl</span><span class="o">.</span><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">bgl</span><span class="o">.</span><span class="n">GL_PROJECTION</span><span class="p">)</span>
   <span class="n">bgl</span><span class="o">.</span><span class="n">glLoadIdentity</span><span class="p">()</span>
   <span class="n">bgl</span><span class="o">.</span><span class="n">gluOrtho2D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
   <span class="n">bgl</span><span class="o">.</span><span class="n">glMatrixMode</span><span class="p">(</span><span class="n">bgl</span><span class="o">.</span><span class="n">GL_MODELVIEW</span><span class="p">)</span>
   <span class="n">bgl</span><span class="o">.</span><span class="n">glLoadIdentity</span><span class="p">()</span>

   <span class="c1"># blf settings + draw</span>

   <span class="n">font_id</span> <span class="o">=</span> <span class="n">bge</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">font_id</span>
   <span class="n">blf</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">font_id</span><span class="p">,</span> <span class="p">(</span><span class="n">width</span><span class="o">*</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="n">height</span><span class="o">*</span><span class="mf">0.3</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
   <span class="n">blf</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">font_id</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">72</span><span class="p">)</span>
   <span class="n">blf</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">font_id</span><span class="p">,</span> <span class="s2">&quot;Hello World&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>On the book files, in the same folder, you can find two other examples following the same framework: hello_world_2.blend and object_names.blend.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="introduction.html" class="btn btn-neutral float-left" title="Introduction to Scripting" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="understanding_inheritance.html" class="btn btn-neutral float-right" title="Inheritance And Composition" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright : This page is licensed under a CC-BY-SA 4.0 Int. License.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>